
用Posits做线性代数：一种新范式
==============================

高斯消去法是一种迭代方法
------------------------

浮点数擅长的一件事是猜测线性方程组\ :math:`A x=b`\ 的答案
:math:`x`\ ，其中 :math:`A` 是 n × n 矩阵，\ :math:`b`
是给定的n值向量。（至少，它们\ *在某些条件下表现良好*\ ，并且人们已经学会忍受这些限制。）LINPACK
基准测试用 -1 到 1 之间的随机数填充 A，并将每行的总和分配给 b 的值，因此
答案应该是 :math:`x=\{1,1,…,1\}`\ 。 我们使用下划线和上划线运算符来确保
A 中的每个数字都在两个数字系统的表达词汇表中。
该基准测试以一种看起来像某种浮点的方式指定数字的 64 位表示，不一定是
IEEE 754 标准； 因此，64 位posit肯定可以在 LINPACK 基准测试上使用！

需要 64 位精度是有充分理由的，我们现在将对此进行探讨。
比如说，如果我们尝试使用 16 位浮点数和位置，会发生什么？
另外，如果我们认识到所谓的“直接求解器”只是通常在一次迭代后停止的迭代求解器，会发生什么？
（除非以无限精度执行高斯消去法，否则它只能给出近似解，并且通常必须迭代应用以纠正残差。）

我们还做了一些新的事情，就是在基准规则设计去修正误差。
驱动程序假设答案是 x={1,1,…,1}，但这错误地假设计算 b 时没有舍入！ A
中的值具有一定的大小范围，因此行的精确总和通常包含比精确到浮点或posit的小数部分更多的有效位。
因此，我们调整 A 的每一行中的最小值，以确保右侧 b 没有舍入。 以下是使用
16 位 IEEE 浮点数的示例。 如果数字 a 可以用 p 位精确表示，则 **powQ**
辅助函数返回 True，否则返回 False。

.. figure:: assets/image-20230717134329501.png

   image-20230717134329501

设置环境。 一次一行地创建 A
矩阵，在最低有效位中对其进行调整，直到其总和达到可以精确表示的数字；
如果调整失败（在某些不常见的情况下会发生这种情况），它只会生成一个新行并重试。
这似乎让人想起\ *逆向误差分析*\ ，其中四舍五入的算术产生的答案被认为是接近指定问题的精确解决方案；
但这里要做的不是。 这只是完成了 LINPACK
的设计目标，即创建一个理想化的问题，其中输入值和正确答案都可以用计算环境的数字词汇来表达。

.. figure:: assets/image-20230717134716522.png

   image-20230717134716522

使用精确算术检查行总和是否等于右侧（使用 quire 可以轻松完成）：

.. figure:: assets/image-20230717134843821.png

   image-20230717134843821

我们用LINPACK风格解该系统。
高斯消去法的部分主元消去法*，每次操作后舍入。 下面是算法，在不调用类似
BLAS 的例程的情况下尽可能简洁。

.. figure:: assets/image-20230717151442121.png

   image-20230717151442121

该求解器将在 Mathematica
中使用精确的有理数算术，因此在我们的样本矩阵上测试它：

.. figure:: assets/image-20230717151537055.png

   image-20230717151537055

如果我们没有“纯化”输入矩阵，我们就不会得到这个答案，而是会看到一堆接近 1
的有理数，其分子和分母都是巨大的整数。

对于求解器的 IEEE 浮点版本，我们通过使用现已成为 IEEE 754 标准 (2008)
一部分的乘加融合来尽可能提高其准确性。
下面的代码中只有四个地方需要四舍五入到最接近的浮点数，如下划线所示。

.. figure:: assets/image-20230717151925930.png

   image-20230717151925930

我们应该得到一个非常接近 1 的有理数（浮点数）列表。我们还计算答案与所有
1 的平均偏差：

.. figure:: assets/image-20230717153906423.png

   image-20230717153906423

半精度 IEEE 浮点数的小数精度在大约 3 到 3.3
位小数之间波动，但我们最终的精度只有大约 1 位小数（最坏情况）。
出于比较目的，posit版本与浮点版本相同，并且还包括融合乘加。
（可以重新排列循环，使最里面的循环是点积，从而使每个结果值所经历的舍入次数再次减少
n 阶。）

.. figure:: assets/image-20230717163147435.png

   image-20230717163147435

同样地我们可以生成 100 个输出值（接近 1 的有理数）的列表，并找到它们与 1
的平均偏差。平均浮点误差比平均posit数误差大约 50%。

.. figure:: assets/image-20230717163402560.png

   image-20230717163402560

对于 100×100 这样大的矩阵使用 16
位数字显然是有风险的，因为我们只有大约三位小数数字的精度，但需要累加最多
100 个数字的总和。 我们可以计算\ *残差*\ ，即差异向量
:math:`b-Ax`\ 。在posits的情况下，可以使用 quire
计算残差，仅四舍五入一次。
对于浮点数，需要使用融合乘加法通过矩阵向量乘法循环来拼写出来。

.. figure:: assets/image-20230717163921066.png

   image-20230717163921066

如果我们现在求解右侧的残差，我们可以使用这些解来校正结果。
这实际上是牛顿-拉夫森迭代的一种形式。
顺便说一句，我们在这里再次调用求解器是偷懒的，因为求解器将矩阵分解为下上形式，我们所要做的就是使用它来反求解，工作量为
:math:`n^2`\ ，而不是 :math:`n^3` 从头开始进行线性求解。

.. figure:: assets/image-20230717164147609.png

   image-20230717164147609

更正后的posit形式现在非常接近，有几种情况在答案向量中恰好达到 1。

.. figure:: assets/image-20230717164353337.png

   image-20230717164353337

浮点残差校正仅将结果提高了大约 2 倍，并且仍然永远不会精确地达到正确答案
1：

.. figure:: assets/image-20230717164426931.png

   image-20230717164426931

以下是与全 1 正确答案的平均偏差以及错误图（已排序）：

.. figure:: assets/image-20230717164648572.png

   image-20230717164648572

另一次迭代不会改善浮点结果。 但看看它对 posit 结果有何影响； 它搞定了！

.. figure:: assets/image-20230717164853872.png

   image-20230717164853872

posit的答案是\ *无限准确的*\ 。
校正技术对于浮点数来说价值有限，因为您确实需要一个quire才能正确进行残差校正。
由于它仅稍微改善了答案，因此大多数人从不费心进行多次高斯消去法迭代，并将其称为“直接方法”。
但事实并非如此。 这是一种猜测方法，通常会朝着解决方案的方向发展。

当我们这样做时，我们可以使用 64 位 IEEE 浮点和相同的 100×100
矩阵来重现原始的 LINPACK 基准测试。 让我们看看效果如何，我们选用 6
点小字以获得紧凑的显示

.. figure:: assets/image-20230717170154613.png

   image-20230717170154613

答案很接近，但缺少正确值 1，每个项都不是。
为了更容易阅读，下面是将答案向量的前几个项表示为小数，最多 54 位：

.. figure:: assets/image-20230717170249400.png

   image-20230717170249400

选择似乎很明确； 使用 64
位浮点数并为答案向量中的每个项拿到错误答案，或者使用 16
位posit并为每个项拿到正确答案。
尽管使用了残差校正，但几乎肯定会\ *更快地*\ 解决问题，并且达到目的只使用
1/4 的存储空间。

使用 16
位posit的限制是，当矩阵是像这样的随机元素时，较大n导致它们会超出动态范围。如果矩阵正定（对于实际物理模拟所需的线性系统来说通常如此），那么
16
位posit应该能够产生可靠到小数点后三位左右精度的答案，这通常足以满足科学问题和工程目的需要。

贝利的数字噩梦，重新呈现
------------------------

回想一下《错误的终结》一书中的这个例子：大卫·贝利 (David Bailey)
提出了一个 2×2 线性系统，其条件数几乎是最糟糕的。
该矩阵距离奇异矩阵仅差一个 ULP！ 他将问题提出为

.. math::


   \begin{pmatrix}
   0.25510582  & 0.52746197 \\
   0.80143857  & 1.65707065
   \end{pmatrix}
   \begin{pmatrix}
   x \\
   y
   \end{pmatrix} = 
   \begin{pmatrix}
   0.79981812 \\
   2.51270273
   \end{pmatrix}

答案是\ :math:`x=-1,y=2`\ 。 即使这些值只有 8 位和 9
位小数，使用精度约为 16 位小数的双精度浮点数也会遇到麻烦。
贝利的部分观点是，将小数转换为二进制表示形式时存在舍入误差，该误差会因矩阵的病态而放大。
但这里有一种表达问题的方法，消除了将十进制小数转换为二进制时的舍入误差，其中我们使用变量\ :math:`\begin{pmatrix} a & b \\ c & d \end{pmatrix} \begin{pmatrix} x \\ y \end{pmatrix} = \begin{pmatrix} u \\ v \end{pmatrix}`\ 代表系统：

.. figure:: assets/image-20230717211056523.png

   image-20230717211056523

所有这些输入值现在都可以用双精度 IEEE 浮点数精确表达。 Mathematica
可以确认确切的答案：

.. figure:: assets/image-20230717211209179.png

   image-20230717211209179

然而，这仍然不足以使浮点数免受可怕的舍入错误的影响。 由于系统只有
2×2，我们可以使用 Cramer 规则以紧凑的形式写出解：

|image-20230717211421760| 虽然在该精度下可以正确计算行列式，但
:math:`u d-b v` 却不能，从而导致 x 值出现无限小数误差下溢。 如果我们使用
64 位posit (es=3)，我们会得到正确的值 (-1,2)。
但posit还有多余的准确性来解决这个问题； 我们可以将 nbits 值一直调低到 59
位，仍然得到正确的结果：

.. figure:: assets/image-20230717211844314.png

   image-20230717211844314

检查此矩阵的条件数，了解为什么“贝利的数字噩梦”是测试用例的一个很好的昵称：

.. figure:: assets/image-20230717212011907.png

   image-20230717212011907

适定系统的条件数的大小接近 1。即使输入值（和正确答案）的大小都接近
1，您仍然可能会得到一个可怕的条件数，从而产生非常错误的结果。 对于
posits 来说，这种情况仍然可能发生，但是 posits 确实比 float
提供了更多的保护！ 如果我们要求 Mathematica 按照 Bailey
的意图求解使用十进制输入表示的系统，会发生以下情况：

.. figure:: assets/image-20230717212225490.png

   image-20230717212225490

XSC 方法
--------

valid 环境的区间算术替代品
~~~~~~~~~~~~~~~~~~~~~~~~~~

20 世纪 80 年代，卡尔斯鲁厄大学的一群数学家（包括 Kulisch 和 S. Rump
等人）开发了使用线性求解器的 quire
类型细化来改进各种运算的方法，而不仅仅是 :math:`Ax=b` 的解。
例如，他们演示了多项式、有理函数和数值导数的计算精度在 0.5 ULP 以内。
关键思想是将此类计算编写为一系列运算，具体取决于 :math:`+ - \times \div`
对先前计算的值的运算，然后可以将其重写为下三角的稀疏方程组。
反过来，可以使用精确的点积以非常高的精度解决这个问题。 虽然 PASCAL-XSC
和 ACRITH
等语言使用该方法，但缺乏quire标准（以及支持该标准的快速硬件的可用性）阻碍了它们的广泛采用。
posit 环境可以利用 Karlsruhe 小组开发的技术。

他们的方法大部分依赖于区间界限，这让我们希望有一个完整的valid环境。
现在我们可以依靠 Mathematica 中的内置区间算术,
尽管它不像一个完整的valids环境。 稍后我们将需要它来使用 quire
进行迭代细化。 目前，这应该被视为原型环境中\ *未完成*\ 的部分。
**x2pint** 函数采用实值或具有实端点的区间，并返回具有 posit
端点并包含原输入参数的区间。 （代码不全，太长了，见原文）

.. figure:: assets/image-20230717213306502.png

   image-20230717213306502

下面是一个示例，说明如何使用一对posit作为闭区间的端点（valids
可以表示的子集）来找到\ :math:`\pi`\ 值的界限：

用于基本块的 XSC 式求解器
~~~~~~~~~~~~~~~~~~~~~~~~~

Kulisch 和 Miranker
表明，仅具有加减乘除运算的基本块可以转换为下三角方程组，然后使用精确的点积求解到
0.5 ULP 以内。 他们的例子之一：

.. math::


   \text{Find } X= (a+b) \times c - \frac{d}{e}

作为线性代数问题，此表达式相当于求解六个未知数的六个线性方程：

.. math::


   \begin{matrix}
   x_1 = a \\
   x_2 = x_1+ b \\
   x_3 = cx_2 \\
   x_4 = d \\
   e x_5 = x_4 \\
   x_6 = x_3-x_5
   \end{matrix}
   \text{ 变换成系统 }
   \begin{pmatrix}
   1 & & & & &  \\
   -1 & 1 & & & & \\
   & c & -1 & & & \\
   & & & 1 & & \\
   & & & -1 & e & \\
   & & -1 & 0 & 1 & 1
   \end{pmatrix}
   \begin{pmatrix} 
   x_1 \\ x_2 \\ x_3 \\ x_4 \\ x_5 \\ x_6
   \end{pmatrix} = 
   \begin{pmatrix}
   a \\ b \\ 0 \\ d \\ 0 \\ 0
   \end{pmatrix}

我们寻找的 X 是\ :math:`x_6`\ 。 该矩阵是下三角且稀疏的。
现在让我们看看是否可以在 {16,1} posit环境中选取导致舍入误差的值，并使用
Mathematica 精确求解系统作为比较的基础：

.. figure:: assets/image-20230717215038879.png

   image-20230717215038879

以下是与每个值最接近的posit数：

.. figure:: assets/image-20230717215221733.png

   image-20230717215221733

选择的输入值会引起麻烦，从 :math:`32+\frac{3}{64}`
开始，在这种低精度环境中四舍五入到 :math:`32\frac{1}{16}`\ 。 选择 c
值以使乘积大约为 1，然后加上接近 -1 比值（也四舍五入）就会放大相对误差。
现在将精确值与每次操作后舍入得到的计算值进行对比：

.. figure:: assets/image-20230717215656063.png

   image-20230717215656063

对于如此少的操作来说，这是一个很大的舍入误差。让我们看看是否可以修复它。
使用posit线性求解器，然后以 quire
级精度计算残差（最终舍入到最近的posit值）：

.. figure:: assets/image-20230717215854539.png

   image-20230717215854539

现在使用残差作为右侧进行求解，将其添加为第一个解的修正，并将该解表示为posit：

.. figure:: assets/image-20230717220004717.png

   image-20230717220004717

注意到所有的6个数都和goal完全相同了

.. figure:: assets/image-20230717220050147.png

   image-20230717220050147

这就是为什么quire和线性求解器不仅仅是解 A x=b 问题； 它们是评估 + - \* /
操作的基本块序列到半个 ULP 以内的关键，就好像只有一次舍入一样。
稀疏下三角矩阵的设置和迭代求解可以自动完成，正如自 20 世纪 80 年代以来
XSC 语言所证明的那样； S. Rump
估计，它会使总工作量最多增加六倍，通常还要少得多。
即使操作数量增加了六倍，它们使用的是寄存器和最近一级缓存中的变量，而不是主内存。
如果该技术让低精度算术得到满意的结果，那么内存带宽和存储的节省（以及相应的功耗和能源成本的节省）应该是值得额外工作的，特别是如果程序员可以指定在哪里应用该技术
以及哪些地方不可以。

乘法结合律？
~~~~~~~~~~~~

实验：看看该题能否得到乘法的结合律。 使用非常低精度的 posit
环境，一个简单情况舍入后
:math:`(u \times v)\times w \ne u\times (v \times w)` 。

.. figure:: assets/image-20230717221409838.png

   image-20230717221409838

这是正确的乘积，以分数和精确的小数表示：

.. figure:: assets/image-20230718081704244.png

   image-20230718081704244

请注意，这甚至在有 quire 下也无法表达，为 {8,0} posit 环境存储的是
:math:`\frac{1}{4096}` 的整数倍的值。 这是最接近正确乘积的posit数了：

.. figure:: assets/image-20230718082345063.png

   image-20230718082345063

如果我们在每次乘法后进行四舍五入，这三个数字就会违反结合律。
如果我们将最后两项先分组，我们会得到以下结果：

.. figure:: assets/image-20230718082601857.png

   image-20230718082601857

如果我们碰巧将前两项分组，我们会得到最佳答案（精确乘积 pex 的 0.5 ULP
范围内的答案）：

.. figure:: assets/image-20230718082755452.png

   image-20230718082755452

61/64 的错误舍入仅与真实解稍远，因此这是一个敏感的测试用例。
对于这些值，ULP 的一半是 0.0078125。 这是一个“险胜的比赛”； 到精确答案
pex 的距离之间的差异仅为 3/4096：

.. figure:: assets/image-20230718083018929.png

   image-20230718083018929

这表明，当我们在每次乘法后舍入时，浮点乘法通常不具有结合性。
无论我们使用浮点还是posit，都是如此。
（如果我们使用valids，计算乘积的两种方法将始终产生重叠的valids，并且重叠区域可以被视为对正确值的更严格限制。）

*基于 quire 的线性求解器*\ 可以恢复乘法结合性吗？ 将积
:math:`u \cdot v \cdot w` 设置为下三角系统。
当表达式中只有乘法、加法和减法时，始终可以在对角线上使用 1 或 -1
来执行此操作。

.. math::


   \begin{align}
   x_1&=u \\
   x_2&=x_1 \times v \\
   x_3&=x_2 \times w \\
   \begin{pmatrix}
   1 &  0 &  0 \\
   v & -1 &  0 \\
   0 &  w & -1
   \end{pmatrix}
   \begin{pmatrix}
   x_1 \\ x_2 \\ x_3
   \end{pmatrix}
   &=
   \begin{pmatrix}
   u \\ 0 \\ 0
   \end{pmatrix}
   \end{align}

精确求解系统产生的乘积放在变量\ :math:`x_3`\ 中 。

下面是精确的解，对所有变量使用 Kulisch 符号：

.. figure:: assets/image-20230718084426886.png

   image-20230718084426886

以posit精度构造近似逆矩阵 R：

.. figure:: assets/image-20230718084533528.png

   image-20230718084533528

细化矩阵是
:math:`I-R A`\ 。以quire精度计算它并用valid模式界定边界（现在使用
Mathematica 间隔，作为实际valid算术库的替代品）：

.. figure:: assets/image-20230718084735196.png

   image-20230718084735196

我们以quire精度计算\ :math:`R\cdot b`
，然后舍入为近似解\ :math:`\tilde{x}`\ 。

.. figure:: assets/image-20230718085007675.png

   image-20230718085007675

我们使用 quire
精度计算残差（德国人喜欢称之为“缺陷”），并再次找到最接近的posit形式。

.. figure:: assets/image-20230718085254314.png

   image-20230718085254314

现在我们需要一个包围\ :math:`\tilde{x}-\hat{x}`\ 的区间。让我们保守一点，给它可表示的实数的整个范围。

.. figure:: assets/image-20230718100347588.png

   image-20230718100347588

这最终建立了 Kulisch 在《数字计算机的算术》第 31 页上指定的迭代方案。
可证明的界限随着每次迭代而缩小，收紧套索，直到不确定性只有一个 ULP 宽。
需要做更多的工作来证明valids可以比闭区间做得更好。
这是一个区间型算法与传统迭代方法不同的例子；
它们需要精心制作，才能生成\ *压缩映射*\ contractive map。
一些传统的迭代方法不这样做，并且使用区间算术，每次迭代的界限变得更宽松而不是更紧！

注意这里我们不需要用户有专业知识。
编译器可以\ **自动**\ 生成细化过程并生成 ULP
宽度的界限，然后将其四舍五入到最接近的位置。
编译器指令应该说明哪些代码块应该以这种方式确保高精度，以便程序不会因为对不需要高精度的答案的细化而运行速度变慢。
XSC 环境没有这种程度的程序员控制，这是它们没有流行起来的另一个原因。

.. figure:: assets/image-20230718101725633.png

   image-20230718101725633

最后一个元素是一个 ULP 宽，所以我们已经完成了。
我们可以再迭代一次，以表明包围区间现在是稳定的：

.. figure:: assets/image-20230718102006930.png

   image-20230718102006930

稳定后的正确答案是

.. figure:: assets/image-20230718102045710.png

   image-20230718102045710

嗯，它成功了。 它找到了真实乘积的最佳包围区间，只有一个 ULP 宽。 在用
posit 替换边界时，我们将舍入到“偶数”端点 31/32。
这表明，如果需要，quire可以将代数的结合性恢复到posit的计算环境中。
如果我们使用区间算术（valids）进行乘法，则两次乘法后的界限将是两个 ULP
宽。 XSC 方法将其缩小到一个 ULP 宽度，然后进行唯一且一致的舍入。

当即便是quire也无法拯救不适定系统时
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

下面是来自 Kulisch 和 Miranker
的示例，其中残差较低并不意味着您接近答案。 请注意，这不是下三角矩阵；
下三角矩阵的表现要好得多。 这很像贝利的数值梦魇，一个看似简单的 2×2
系统，但实际上却非常不适定。

.. figure:: assets/image-20230718104322128.png

   image-20230718104322128

准确的答案应该是
{1,-1}，使用有理数的精确算术能够得到真正的\ *直接解*\ ，因为没有舍入：

.. figure:: assets/image-20230718104526649.png

   image-20230718104526649

为了设置 XSC 紧包迭代，我们首先找到逆矩阵的posit近似。

.. figure:: assets/image-20230718104632101.png

   image-20230718104632101

将近似逆应用于右侧向量 b 以获得起始猜测（quire精度）：

.. figure:: assets/image-20230718104722111.png

   image-20230718104722111

这些值不需要四舍五入到最接近的posit，碰巧已经是可以表达为posit数。
使用所需精度计算“缺陷”，并四舍五入到最接近的位置：

.. figure:: assets/image-20230718104855522.png

   image-20230718104855522

注意到这是一个相当大的“缺陷”！
问题出在细化矩阵算子\ :math:`ref=I-A\cdot R`\ 上

.. figure:: assets/image-20230718105040141.png

   image-20230718105040141

除非谱半径（最大特征值与最小特征值之比）小于 1，否则我们无法保证收敛。

.. figure:: assets/image-20230718105127445.png

   image-20230718105127445

这里谱半径不小于1，所以我们不应该对残差细化抱有太大希望。
应用“细化”运算符会使事情变得更糟，也就是说，间隔界限将变得更松，而不是更紧。
即使使用quire，残差校正也不起作用。
问题是如此不适定，以至于无法通过这种方式解决。 XSC
的解决方法是检测这些罕见的情况并将其报告给用户。

此外尝试两个候选解。

第一个尝试非常接近正确解，X=0.999，Y=-1.001（使用最接近的posit表示）

.. figure:: assets/image-20230718105441204.png

   image-20230718105441204

我们人类的直觉告诉我们，对于如此接近的猜测，缺陷应该非常小：

.. figure:: assets/image-20230718105522341.png

   image-20230718105522341

对于第二个候选解，尝试更差的猜测，X=0.341，Y=-0.087，并检查残差：

.. figure:: assets/image-20230718111705775.png

   image-20230718111705775

第二个解向量选择显然离正确解更远，但残差更小！
至少我们还可以检测到细化方法何时会失败。
但这里幸运的猜测可能对你没有啥帮助。

Kulish 多项式挑战示例
~~~~~~~~~~~~~~~~~~~~~

Kulisch 给出了多项式的示例，该多项式很难针对某些输入值进行准确评估。
它的精确根为 :math:`1/\sqrt{2}`\ 。
如果我们使用接近该根的值，任何错误都会被放大。

.. figure:: assets/image-20230718114046531.png

   image-20230718114046531

我们可能应该使用霍纳规则写出多项式的定义，与程序实际对多项式求值的方式一样。

.. figure:: assets/image-20230718114218532.png

   image-20230718114218532

Kulisch 的示例使用
:math:`t=0.707107`\ ，并表明多项式计算仅正确到小数点后两位。
公平比较，我们需要使用最接近的二进制表示形式
:math:`\frac{707107}{1000000}` 作为输入量来找到准确的答案。 将环境设置为
32 位posit：

.. figure:: assets/image-20230718114522640.png

   image-20230718114522640

我们可以使用精确有理算术和 97
位小数来表达该分数的精确多项式的结果，当然只有前几位小数是有效数字：

.. figure:: assets/image-20230718115039455.png

   image-20230718115039455

现在看看当我们依赖“机器精度”（即内部 64 位 IEEE 浮点数）时会发生什么：

.. figure:: assets/image-20230718115204562.png

   image-20230718115204562

尽管使用了超过 15
位有效小数，但只有前两位小数是正确的：\ :math:`-1.9\color{orange}326\color{black}\cdots\times10^{-11}`\ 。
我们能否使用 XSC 风格的细化技术，通过 32 位posit获得更好的答案？

使用霍纳规则和五个临时量 :math:`x_1`\ 到 :math:`x_5` 编写 P(t) 的方程：

.. figure:: assets/image-20230718121936391.png

   image-20230718121936391

精确值的最佳 32 位posit表示如下，显示为小数点后 10 位：

.. figure:: assets/image-20230718122101348.png

   image-20230718122101348

颜色编码显示，对于如此小的数值，该小数只有 20 比特位，而 ULP 约为
:math:`10^6` 的一部分。 这是合适的，因为输入值只有六位有效数字。

下面是 :math:`Ax=b` 问题设置和近似解
:math:`\hat{x}`\ ，表示为精确有理数和近似小数：

.. figure:: assets/image-20230718122619859.png

   image-20230718122619859

以下是在posit精度下的近似逆矩阵：

.. figure:: assets/image-20230718122822934.png

   image-20230718122822934

细化矩阵是 :math:`I-R A`\ ，以quire精度计算，然后四舍五入：

.. figure:: assets/image-20230718122929285.png

   image-20230718122929285

我们以quire精度计算
:math:`R \cdot b`\ ，然后舍入以作为近似解，\ :math:`\tilde{x}`\ 。

.. figure:: assets/image-20230718123359394.png

   image-20230718123359394

我们总是以quire精度精确地计算“缺陷”，并四舍五入到posit精度：

.. figure:: assets/image-20230718123048634.png

   image-20230718123048634

现在我们需要围绕 :math:`\tilde{x}-\hat{x}` 的区间包围作为起始猜测。
像往常一样，要极端保守并使用尽可能大的起始间隔。

.. figure:: assets/image-20230718123537074.png

   image-20230718123537074

这最终建立了 Kulisch 在《数字计算机的算术》第 31 页上指定的迭代方案。
我们可以观察 e 的最后一个元素发生了什么，因为这就是我们寻求的答案。

.. figure:: assets/image-20230718123725708.png

   image-20230718123725708

它还有很长的路要走，但正在快速缩小。

.. figure:: assets/image-20230718123800825.png

   image-20230718123800825

看上去不错

.. figure:: assets/image-20230718123840030.png

   image-20230718123840030

这看上去已经收敛了，但是再来一次迭代确保

.. figure:: assets/image-20230718123929461.png

   image-20230718123929461

已经不变了。现在开始应用这个校正值

.. figure:: assets/image-20230718124025529.png

   image-20230718124025529

最后一个间隔是结果界限，到目前为止，它比使用 32
位浮点所能做到的要好，我们稍后会看到的。
但在我们停止之前，让我们尝试使用每个区间中的一个点作为新的起点，因为在纠正最后一项时我们失去了很多精度。
它离正确答案太远了，没有多少有效数字可以真正放大答案。
该方法的优点在于，即使起始点较差且矩阵 A
的逆矩阵非常近似，它也会产生严格的界限。只要 :math:`A R-I` 的谱半径小于
1，包围区间就会收敛到 ULP-宽的界限。 这一定是区间算术界的最高成就之一。

.. figure:: assets/image-20230718124345454.png

   image-20230718124345454

使用这个更好的起始猜测来计算精确的残差：

.. figure:: assets/image-20230718124435365.png

   image-20230718124435365

这个非常小的修正表明这\ *非常*\ 接近真实答案。
但我们并不是简单地使用典型的迭代方法；我们正在证明答案位于一个区间内。
使用通常的全区域的包围区间来开始，并将 d
舍入到最近的posit。（如果我们不将 d 舍入到最接近的位置
:math:`\tilde{d}`\ ，我们就无法使用 quire 来精确计算
:math:`R\cdot d`\ 。

.. figure:: assets/image-20230718124853259.png

   image-20230718124853259

使用与以前相同的细化运算符，但这个更好的起点会迭代，直到事情停止变化。
仅将最后一个值显示为小数，当它看起来稳定时，通过将其显示为有理数来进行检查。

.. figure:: assets/image-20230718125016327.png

   image-20230718125016327

已经稳定了。 加上这个校正值，然后仅查看最后一个值就是答案的界限：

.. figure:: assets/image-20230718125204456.png

   image-20230718125204456

我们可以使用颜色编码输出来显示这些位置边界相距 1 个
ULP，因此这是一个最大精度结果，具有六位小数的精度。

.. figure:: assets/image-20230718125255416.png

   image-20230718125255416

这是相当惊人的，因为 32
位posit产生的答案精确到小数点后六位，并且具有可证明的包围，而 64
位浮点数产生的答案精确到小数点后两位，而不保证任何正确性。 Kulisch
博士得 1 分。

只是为了好玩，让我们看看如果我们使用 32 位浮点数，结果会有多糟糕。
我们将 t 的值转换为最接近的浮点数。

.. figure:: assets/image-20230718125432038.png

   image-20230718125432038

使用该 t 值的多项式的精确值应如下：

.. figure:: assets/image-20230718125534349.png

   image-20230718125534349

以下是每次运算后使用 Horner 规则和 IEEE 标准舍入计算的多项式。
看到一堆下划线很有趣，它们准确地告诉您舍入发生的位置。

.. figure:: assets/image-20230718125619883.png

   image-20230718125619883

啊呀，无限误差。浮点算术认为该值是多项式的根！
但是等等，我们至少可以使用融合乘加，这将舍入次数从 8 减少到 4：

.. figure:: assets/image-20230718125741388.png

   image-20230718125741388

这看起来比我们计算的正确值 fex 大很多。 让我们看看误差有多大：

.. figure:: assets/image-20230718125828111.png

   image-20230718125828111

现在答案相差了 260 万倍。 好吧，至少它的符号位还是对的！

posit算术、quire累加和收缩包围区间技术的结合使 32 位posit的性能显着优于
64 位浮点数。 32
位posit产生了一个严格的、可证明的界限，具有六位小数的精度，而 64
位浮点数产生了一个猜测，但不能指示猜测中有多少个小数是正确的。实际上只有前两位小数是正确的。

解决真正的偏微分方程问题（用Sandia的数据集）
--------------------------------------------

关于 Ax=b 和 quire 数据类型的见解
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

如果 A 和 b 用posit（或浮点数）表示，并且 A 是非奇异的，则 x
仅有\ **一个**\ 答案：有理数向量。

恰好有一个 :math:`\tilde{x}` 可以posit数来表达且比任何其他数更接近 x
的。（舍入是唯一的）。

矩阵 A 乘以 x 是一个 quire 向量，没有舍入误差！ （如果我们使用 32
位posit，则每个quire是 512 位。）

使用精确点积作为最内层循环的高斯消除意味着每个元素进行 :math:`O(n^2)`
舍入，而不是 :math:`O(n^3)`\ 。 对于 :math:`n \approx 10^6` 的 petascale
问题，这意味着答案中的精确度大约为三位小数。

让我们看看是否可以从Sandia导入一个基于真实偏微分方程的小测试文件。
从他们的 81 个变量系统开始，显然是使用 5 点模板通过 9×9 泊松问题生成的。
前两个数字是矩阵内的行列坐标，长小数是双精度分量值。
对于本文档中间的长数字表表示歉意…！

这里只截取部分图

.. figure:: assets/image-20230718135741955.png

   image-20230718135741955

虽然这显然应该作为稀疏矩阵存储和求解，但为了快速原型设计，我们只需填充一个稠密矩阵，以便我们可以使用上一节中开发的稠密矩阵求解器。
与使用最近邻模板（有限差分）近似求解的偏微分方程一样，系统具有主对角线、相邻对角线和相距
9 个元素（即方形域的宽度或高度）的对角线。 该图显示了具有 z
维度系数值的矩阵。

.. figure:: assets/image-20230718135952691.png

   image-20230718135952691

Sandia还提供了其右侧向量
b，该向量与矩阵输入值的小数近似质量没有明显差别。

.. figure:: assets/image-20230718140544777.png

   image-20230718140544777

显然，该矩阵是由精确有理数构造的。
Sandia同意重建这些原始有理数，这将使我们能够缩放 A 和 b 以改进 A
的表述。如果我们将 A 乘以 120，所有值都会变得非常接近整数。 再使用微小的
3点字符，整个矩阵就适合页面宽度。

.. figure:: assets/image-20230718140947491.png

   image-20230718140947491

这是Sandia使用传统双精度浮点提供的“正确答案”。 我们预计其精度接近 15
位小数，因为该矩阵似乎对角占优且是良态。

conditioned matrix
在一般线代教材里不讲的，它主要涉及矩阵计算的数据敏感性分析，比如对于一个Ax=b，它要衡量的是：若有一个Δb，则Δx会有多大？如果Δx不很大，则这是一个well
conditioned matrix，如果Δx很大，则它就不是一个well
conditioned的矩阵了，甚至是一个ill conditioned matrix了。

对于一个矩阵，在矩阵的大特征值方向上(λ＞＞1)，有Δx=1/λ
Δb，Δx比Δb还小，就很well；若在矩阵小特征值方向上，也有λ＞1，这个矩阵肯定是well
conditioned 的了。但如果有特征值很小(极端是0)，则按Δx=1/λ
Δb公式，一个Δb就会对应一个很大的Δx，这就不是well conditioned 的矩阵了。

从图形上看，在x按圆周分布时(x长度不变，方向变)，由y=Ax得到的y一般会按椭圆分布。一个well
conditioned的矩阵会产生一个长短轴方向上的y模长都不比对应的x模长小太多的y椭圆分布，或者说是最小的特征值λ也距离零足够远。最严重病态的矩阵ill
conditioned mayrix就是有特征值为零的矩阵了吧。

.. figure:: assets/image-20230718141554898.png

   image-20230718141554898

用mathematica的内置求解器开始

.. figure:: assets/image-20230718141804248.png

   image-20230718141804248

计算残差以检查这是否是准确的答案：

.. figure:: assets/image-20230718142825566.png

   image-20230718142825566

这看起来是一个准确的答案！ 也许我们可以制作它的 3D 图。

.. figure:: assets/image-20230718142859082.png

   image-20230718142859082

让我们尝试仅使用 16 位posit数来解决这个问题，看看会发生什么。

.. figure:: assets/image-20230718142946057.png

   image-20230718142946057

下面是残差：

.. figure:: assets/image-20230718142442927.png

   image-20230718142442927

如果我们用它来修正答案，我们会得到一个与Sandia提供的结果相匹配的结果，达到
16 位posit的精度：

.. figure:: assets/image-20230718142618705.png

   image-20230718142618705

.. figure:: assets/image-20230718142639983.png

   image-20230718142639983

.. figure:: assets/image-20230718142705171.png

   image-20230718142705171

答案中的任何差异都太小而无法看到。
使用残差校正方法，似乎没有理由使用高于 16
位的posit精度，而如果任何数据都用 64
位表示，则显然有能力解决更大的问题。 quire允许 16 位posit数完成 64
位浮点数的工作。

Unum 线性求解器的时间复杂度
---------------------------

:math:`A x=b` 问题的 A 和 b 输入在实际应用中可以是近似的。
区间算术有一个定理，该定理指出，找到整组 x
值的精确数学描述来满足具有输入区间界限的线性方程是 NP 困难的。
有一个简单的方法可以理解为什么会这样：精确矩阵的每一行都指定 n
空间中的一个超平面，而解就是 n 个超平面的交集。 例如，2×2
线性方程组仅表示两条直线的交点。

.. figure:: assets/image-20230718143946083.png

   image-20230718143946083

当在数字系统中指定方程时，无论是浮点还是posit数，确切的交点的坐标通常不是浮点或posit，尽管它们是有理数。
如果分母正好是 2 的幂，因此它们出现在数字词汇中，那只是巧合。
有一个唯一的最接近答案的点，只需通过对答案向量的每个元素进行四舍五入即可找到。

如果矩阵系数是间隔而不是精确点，则单行表示 n 个“超板”的交集，即 n
空间中由“板”界定的区域。
找到交集的唯一方法是检查边界的最小值和最大值的每种可能组合, 或
:math:`2^n` 超平面。
严格界限意味着找到\ :math:`n^2`\ 个矩阵元素和\ :math:`n`\ 个右侧元素中每个元素的最小值和最大值的超平面，总共\ :math:`2(n^2+n)`\ 种情况。
即使 n 小到 2，表示结果的精确几何交集也很难计算，如下图所示。

.. figure:: assets/image-20230718144843051.png

   image-20230718144843051

假如我们先简单地找到一个似乎可以解决 A x=b 的特定解 x，然后扰动 x
以找到其他可行的解，迭代直到我们找到所有解决方案，怎么样？ 这就是基于
ubox 的方法之一，使用多维向量进行计算，这些向量每个分量(或
ubox)要么是精确的值，要么是一个 ULP
宽的开区间。在下图中，黑点是您喜欢的任何求解器产生的第一个猜测（并检查它是否确实在四舍五入后求解了方程）。
那是一个在所有维度上都精确的 ubox，也是探索的种子。
通过测试相邻点，看看它们是否也满足 A
x=b（其中“=”表示与右侧向量的区间有交集），我们可以“绘制”复杂形状的内部，以找到所有的ubox组成的解集，如下图浅绿色所示。
红色边框代表一个可证明不满足 A x=b 的 ubox。 也就是说，精确的矩阵 A 乘以
ubox x 会得到不与 b 的所有分量相交的区间。

.. figure:: assets/image-20230718145721723.png

   image-20230718145721723

虽然这种方法的优点是可以在大规模并行计算机上轻松完成，并且编程比将超平面与计算几何相交要简单得多，要注意的是通过每个分量中的
ULP 扰动 x 值意味着 :math:`3^n` 扰动 在每个维度中，因为每个分量都可以按
ULP 下降、保持不变或按 ULP 上升。 它适用于 n 的一些值，但不是非常大的
n。 例如，对于 n=100 的 LINPACK，必须测试 3^100
个输入向量（ubox）显然很棘手。 矩阵是稠密还是稀疏并不重要。
乍一看，这似乎是 ubox 类型求解器获得合理时间复杂度的一个僵局。

然而，LINPACK 示例带来了一个见解：在第 12.1 节中，我们扰动了 A
矩阵，使得精确答案与\ :math:`x_i`\ 的所有 1 值的预先设想的解相匹配。
这是\ *逆向误差分析*\ 的一种形式：一个问题的近似解可以被视为另一个问题的精确答案，如果不同的问题只是略有不同，那么我们可能会接受这个答案。
这一论点可以追溯到 20 世纪 50
年代威尔金森关于数值分析的经典论文，当其他问题与最初提出的问题相邻时，他创建了存在性证明。
但逆向误差分析实际上并没有构造出改变后的问题；
它只是表明它在某些条件下存在。

--------------

通过 unum
算术，我们可以\ **显式地构造改变后的问题以进行逆向误差分析**\ 。
此外，这使我们能够使完美、有界解的时间复杂度变得像所有当前求解 A x=b
的数值方法一样简单。

--------------

LINPACK 基准测试的原始随机矩阵 A 已更改，以便使用 posit
词汇表将解向量表示为 n 维空间中的精确点。
该解向量的每次扰动都无法求解线性系统！ 这样我们就完成了。
只有一个“ubox”来解决这个系统，并且它在所有维度上都是精确的，并且在每个分量都是精确的1。
没有 ULP 范围。 顺便说一句，传统的区间算术无法实现这一点；
传统的区间算术使用 [a,b] 形式的闭区间，其中
:math:`a\le b`\ ，并且该精确点的所有 :math:`3^n-1`
个邻居也会产生一个在每个分量中接触 b
的向量，因此它们仍然会产生难以处理的时间复杂性。 对于 unum
算术，valids是开区间，并且不包括满足 :math:`A x=b` 的端点。
这意味着精确解的任何开区间邻居都是上图中红色边界的一部分。 迭代方法为
:math:`O(n^3)`\ 因为原始高斯消除（LU 分解）为 :math:`O(n^3)`\ ，而迭代为
:math:`O(n^2)`\ 因为它们仅依赖于使用 quire 求矩阵向量乘积 以及用
:math:`U^{-1}` 和
:math:`L^{-1}`\ （高斯消元法形成的三角矩阵）进行反解，所有这些都只需要
:math:`O(n^2)` 的工作。 因此，对于 :math:`n×n` 系统，求解 LINPACK
的时间复杂度为 O(n^3)，即使使用迭代方法来获得完美的单一精确解。
这个结果似乎是新的。

然而，对于实际问题，我们通常无法选择调整矩阵条目。
桑迪亚的测试数据就是一个很好的例子。 请记住，缩放 120
后，矩阵全部为整数：这是因为它是由表达模板运算符产生的，例如

.. math::


   x_{i,j}=(x_{i-1,j}+x_{i+1, j}+x_{i, j-1}+x_{i, j})/4

除了 LINPACK 的情况外，我们应该将矩阵 A 视为精确的“不可调整”。
这似乎推翻了构建反向误差分析问题的论点。

或者确实如此？

请记住，类型 III unum 具有 quire 数据类型。 当您尝试求解 A x=b
时，您会找到一个近似的
x，无论您使用的是高斯消除法、共轭梯度法还是连续过度松弛法，或者任何您最喜欢的方法。
称之为 :math:`\tilde{x}`\ ，一个 posit 元素的向量，我们希望它导致
:math:`A \tilde{x}` 接近 b。

然后使用精确的点积，我们可以计算 :math:`\tilde{b} =A \tilde{x}`.
确切地。
答案不仅是\ :math:`\tilde{x}`\ ，也是逆向错误分析所需的显式构造问题：

--------------

:math:`A x= \tilde{b}`\ 是一个接近原问题\ :math:`A x=b`\ 的问题，
解就是\ :math:`x=\tilde{x}`\ 。

--------------

限制解区域不存在指数复杂性。复杂度是传统矩阵求解器方法的复杂度，然后原始问题的扰动版本成为解一部分。
也就是说，\ :math:`\tilde{x}`\ 和更改后的 :math:`\tilde{b}`
都被计算并视为问题的输出。 然后用户可以决定 :math:`\tilde{b}`
是否足够接近所请求的 b. 这是解决 A x=b 问题的新范式，而这是由于有 quire
数据类型而成为可能

.. |image-20230717211421760| image:: assets/image-20230717211421760.png
