
概论
====

Unum 用于表达实数和实数范围。
有两种操作模式可供用户选择：posit/定位模式和valid/有效模式。

在 posit 模式下，unum
的行为很像固定大小的浮点数，如果计算结果不能精确表达，则四舍五入到最接近的可表达值；
然而，与相同位数的浮点数相比，posit表示提供了更高的精度和更大的动态范围，以及许多其他优点。
我们可以将它们简称为 posits，就像我们将 IEEE 754 标准浮点数称为 floats
一样。

在valid模式下，unum
表示一系列实数，可用于严格限制答案，就像区间算术一样，但比传统区间算术有许多改进。
Valids 仅在此顺便提及，并在单独的文档中详细描述。

本文档重点介绍 posit
模式的细节，可以将其视为“在浮点数自己的游戏中击败它”。 它引入了一种
unum，即 Type III，它结合了 Type I 和 Type II unum
的许多优点，但不太激进，被设计为 IEEE 754
标准浮点的“直接”替代品，无需进行任何更改 应用程序级别的源代码。
下表可能有助于澄清术语。

+--------+----------+---------------+---------------+---------------+
| Unum   | 引入时间 | IEEE 754      | 优点          | 缺点          |
|        |          | 兼容性        |               |               |
+========+==========+===============+===============+===============+
| I 型   | 2015.3   | 是            | 比特空        | 需            |
|        |          |               | 间占用最有效  | 要管理变长码  |
+--------+----------+---------------+---------------+---------------+
|        |          | 完美超集      | 严格边界表示  | 继承了IEEE    |
|        |          |               |               | 754的缺       |
|        |          |               |               | 点如冗余表示  |
+--------+----------+---------------+---------------+---------------+
| II 型  | 2016.1   | 否            | 每            | 查表限制了精  |
|        |          |               | 比特信息最大  | 度约20b或更小 |
|        |          |               | (可以根       |               |
|        |          |               | 据工作量定制) |               |
+--------+----------+---------------+---------------+---------------+
|        |          | 全新设计      | 完美倒数, (+  | 精确          |
|        |          |               | – × ÷         | 的点积代价昂  |
|        |          |               | 也同样简单)   | 贵或无法实现  |
+--------+----------+---------------+---------------+---------------+
|        |          |               | 用ROM查       |               |
|        |          |               | 表执行非常快, |               |
|        |          |               | 运            |               |
|        |          |               | 行十进制表示  |               |
+--------+----------+---------------+---------------+---------------+
| III 型 | 2017.2   | 相似          | 硬件实现友好  | 太新了        |
|        |          |               |               | 没有芯片支持  |
+--------+----------+---------------+---------------+---------------+
|        |          | 可以转换      | 可直接        | 完美倒        |
|        |          |               | 替换IEEE浮点  | 数仅限于2^n,  |
|        |          |               | (改变不激进)  | 0和 inf       |
+--------+----------+---------------+---------------+---------------+
|        |          |               | 比            |               |
|        |          |               | 浮点更快，更  |               |
|        |          |               | 精确和低成本  |               |
+--------+----------+---------------+---------------+---------------+

第三类Posit使用定长位数，尽管该数字非常灵活，能支持从少至两位到数千位。
它们专为简单的硬件和软件实现而设计。 它们使用与 IEEE 754
浮点数相同类型的低级电路结构（整数加法、整数乘法、移位等），并且占用更少的芯片面积，因为它们在许多方面比
IEEE 浮点数更简单。 早期的 FPGA
实验表明，与相同精度的浮点数相比，posit的延迟显著减少。

与所有 unum 类型一样，有一个用户可读值的 h(human) 层、一个用 unum
表示值的 u 层、以及一个精确且临时执行数学运算的 g 层，结果返回到 u 层。
在这里，h
层看起来非常像标准的十进制输入和输出，只是我们在传达精确值和舍入过的值之间的差异时会更加小心。
u 层是 posit 格式的数字，对于程序员来说，它看起来非常像浮点数。 g
层表示临时（草稿）值：quire，能执行遵守代数分配律和结合律的精确运算，能以比浮点数更少的位数实现惊人的高精度。
要解释的东西有很多，但让我们从 u
层开始，因为它是与浮点运算最接近的表亲。

posit模式的格式简述，III型unum数
--------------------------------

III型unum数的posit格式是硬件友好的设计，如下图描述

.. figure:: ./assets/Pasted_image_20230712135819.png

   Pasted image 20230712135819.png

仅在符号位之后有画区域边界的实线，其他边界因为会随着\ **regime字段**\ 的大小而变化就没有画。
**regime字段**\ 编码是连续相同比特位
:math:`r`\ ，终止在末尾\ :math:`\overline r`\ 位上。
这种表示整数的方式有时被称为“一进制算术”，但实际上它略复杂一些。
记录整数最原始的方式是用标记，其中标记的数量就是所表示的数字。
想想罗马数字，

.. raw:: html

   <pre>1=I、2=II、3=III，但随后它换用不同的系统来表示 4=IV。</pre>

或者中文和日文中

.. raw:: html

   <pre>1=一，2=⼆，3=㆔，但随后它换用不同的系统来表示 4=㆕。</pre>

我们看到这个系统超过 3 后就用了\ **划记的标记**\ （ **tally
marks**\ ），也就是无数漫画描绘囚犯跟踪他们在监狱里呆了多少天的方式。
但是划记标记如何同时记录正整数、零整数和负整数呢？
我们可以想象早期记录这个概念的尝试：

.. figure:: assets/image-20230712142052141.png

   image-20230712142052141

其实我们有能力使用两种“刻度线”：零和一。
这意味着我们可以通过重复不同标记来分别表达正整数和负整数。
例如，负整数通过重复 0 比特，零或正整数通过重复 1 比特来表示。

**指数字段**\ 的长度为
:math:`es`\ ，但如果这些位被\ **regime字段**\ 挤到了 unum
的末尾，那么其的长度可能会小于 es。 对于习惯了 IEEE
浮点数的人来说，这通常是令人困惑的部分。“等等，指数字段到底在\ *哪里*\ ，有\ *多少位*\ ？”
它们的工作方式与浮点数的指数字段不同。 它们可以左右移动，也可能被剪掉。
现在先将regime字段和指数字段视为在一起表示整数
:math:`k`\ ，用来将数字的缩放\ :math:`2^k`\ 倍。

**小数字段**\ 是符号位、regime字段和指数字段未使用的剩下的比特位。
它们的工作方式与标准化浮点数的小数字段完全相同。 这是 Type III
具有硬件友好性的主要原因。
就像正则化（二进制）浮点数一样，表示形式归结为

.. math::


   (-1)^{\text{符号}} \times 2^{\text{整数k}} \times (1 + \text{小数})

硬件设计人员会很高兴听到：没有像浮点数那样的“次正规(subnormal)”的posit数，只有一种舍入模式，并且只有两个异常值（0和\ :math:`\pm\infty`\ ）不遵循上面的公式。

引入\ **regime字段**\ 的原因是它们自动且经济地创建\ *锥形精度*\ ，其中小指数的值具有更高的精度，而非常大或非常小的数字具有较低的精度。（IEEE
浮点数有一种粗略的锥形精度形式，称为小数值的\ *渐进下溢* gradual
underflow, subnormal，但对于大数值，它们没有等效的形式。）
锥形精度的想法最初由 Morris 于 1971 年提出，并在 1989
年创建了完整的实现。但它使用一个单独的字段来指示指数中的位数。该方案不仅浪费了位，而且还导致了多种位模式都表示了相同的数字，从而在做比较
x<y 和 x=y 时造成了无可救药的复杂与混乱。
III型posit数不会发生这种情况：每个位串都有唯一的含义，比较操作等同于看作有符号整数的比较。

**posit环境**\ 通过指定两个数字来设置：nbits（posit 的总位数）和
es（指数字段的最大大小）。
同样，这些字段表示的数值与浮点数中字段的工作方式类似，不同之处在于：

-  如果符号位为 1，则在解码剩余字段之前对 unum 位串取负（将其视为标准 2
   的补码整数）。
   这消除了对“负零”和所有不同模式表示相同实数的情况带来的复杂性。（如果不需要先取绝对值，硬件就直接解码一个
   posit
   位串，的确可以使得电路更快更简单。但这使得解释会更复杂，所以这里我们缺省就使用
   2 的补码 表示负posit数的值。）
-  测试两个整数是否相等的机器指令也将用于比较两个posit数，而浮点数指令还需要额外的负零异常测试（当位模式不同时值也可能相等）以及
   NaN 值检查（当位模式相同时值也可能不等）。
-  相同regime字段 r 的数量决定了缩放该值的的正或负幂
   :math:`2^{2^{es}}`\ ，指数字段将值缩放为 2 的幂，范围从\ :math:`2^0`
   到 :math:`2^{2^{es}-1}`\ 。
   比如\ :math:`es=3`\ ，三个指数位可以表示从\ :math:`\color{blue}{000}\color{black}=0`
   到 :math:`\color{blue}111\color{black}=2^3-1=7`
   的二进制整数。regime字段决定 :math:`2^3=8`
   的正幂或负幂，因此regime字段和指数字段一起可以表示一个有符号整数 k
   （就是解码后拼接起来: :math:`r*2^{es}+e=r*8+e`
   ），k的工作方式类似于浮点数中指数位表示的整数。
-  不存在次正规subnormal（非正规化denormal）数字。
   小数字段之前隐含的“隐藏位”始终为 1。
-  Posit不会像浮点数那样下溢到零或上溢到无穷大。舍入到最接近的数字，其中“最近”是指舍入对于小数字段时有最小差值，而指数字段时有最小比率。
   处理器的状态中没有隐藏任何标志来表明计算期间发生了某些事情；
   你所看到的就是你得到的。
   在开发代码时，调试工具可以提供丰富的有关下溢、上溢以及其他异常的信息，但在正常操作期间它们不会给处理器带来负担。

posit算术定义的另一个主要组成部分是
**quire**\ ，有固定长度的比特数，用于在 g
层中用来做暂存器，使得操作在数学上是精确的。 quire
可以被认为是一个专用寄存器，它允许执行点积、求和和其他运算，并将舍入误差推迟到计算的最后。
所有计算机都使用隐藏的暂存区进行临时计算。 在 posit
算术中，程序员可以访问 quire 数据类型，这使得 posits
比浮点数更严格地遵循代数规则。 quire 的概念非常强大。
它允许段位“超越其体重等级”。 稍后我们将展示一些示例，其中 16
位posit在速度和准确性方面都优于 64 位浮点数！

一个16 位示例
-------------

人们总是要求立即查看一个示例，而不是费力地阅读一长串仔细的定义。
下面是一个关于 16 位位置的位字段如何工作的示例。 选择
es=3，因此regime字段按 :math:`2^{2^3}=256` 对正负幂做缩放。
注意：“标准的”16 位 posit 的 es 大小为 1，而不是 3，但出于说明目的，此处
3 效果更好。

.. figure:: assets/image-20230712222454215.png

   image-20230712222454215

符号位为\ :math:`\color{red}0`\ 表示该值为正。 regime字段是由
:math:`\color{DarkOrange}1` 终止的三个
:math:`\color{Orange}0`\ ，这意味着useed的幂为 -3。
regime带来的缩放因子为 :math:`256^{-3}`\ 。 指数位
:math:`\color{blue}101` 是无符号二进制整数5，表示另一个缩放因子
:math:`2^5`\ 。 最后，小数位 :math:`11011101`
是无符号二进制整数221，代表小数 :math:`1+221/256`\ 。
整个比特串表达式的值是
:math:`477 \times 2^{-27} \approx 3.55393 \times 10^{-6}`\ 。

regime字段可能看起来是很奇怪的构造，它们实际上是将实数轴投影到圆上，用自然而优雅的二进制整数的几何映射产生的。
字段的提取及其含义将在稍后详细讨论。

请注意，此处指数可表示的最大移位为 :math:`\color{blue}111`\ =7 位，即
:math:`2^7`\ 。 这意味着指数可以将小数缩放
1、2、4、8、\ :math:`\cdots`\ 或 128。如果您需要缩放 256
倍，这就是regime字段的用武之地，因为它们表示 256 的幂次。

Posit的两个异常值
-----------------

上面对位字段及其含义的描述仅对两个比特串是例外：(regime没有ending了)

-  如果所有位均为 0，则表示的数字为零。
-  如果只有第一位为 1，其余为
   0，则表示的值为\ :math:`\pm\infty`\ ，有时称为“射影无穷大”或“复无穷大”或“无穷远点”。
   如果您无法输入“:math:`\pm\infty`”，则可以使用 inf 来表示相同的含义。
   值\ :math:`\pm\infty`
   和零互为倒数，任何非零数除以零都不会触发错误条件；
   它只是\ :math:`\pm\infty`\ 。 第 2 节中的图表将使这一点更加清晰。

.. raw:: html

   <table border="4">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

只有一种舍入模式：舍入到最接近、与 IEEE 754
浮点数的默认舍入到最接近的偶数模式相同。如果程序员或用户觉得需要其他三种浮点的舍入模式（向下舍入、向上舍入、向零舍入），则意味着应用程序需要的是valid模式，而不是posit模式，或者也可能只是要个好的调试工具。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

舍入中“最近”的含义比浮点数复杂一些，因为右侧被截断的位不一定是小数字段；
部分或全部指数字段也可以被剪掉。
当指数位被剪掉并且必须进行舍入时，“最近”意味着“最接近的指数”，其连接点其实是两个选择之间的几何平均值而不是算术平均值（指数的算术平均就是值的几何平均）。
如果您担心这一点，请想到这种情况事实上很少发生，并且仅在计算即将达到动态范围的极限时发生，因此它可能已经偏离轨道并且需要调试算法。

如果计算超出最大可表示位置一定量，它是否应该溢出到无穷大？ 当然不是！
这会将一些有限的错误变成\ *无限*\ 错误的答案。 这是浮点数才做的事。
同样，我们绝不允许下溢为零，因为这样做意味着丢弃了答案…甚至包括其符号在内的\ *所有*\ 信息。
与使用了非标准舍入模式一样，如果需要区分下溢、上溢和 NaN
通常表明应用程序仍处于开发阶段，尚未准备好用于生产使用。 引用 Donald
Knuth
的话：“不幸的是，在许多情况下，忽略指数下溢，并简单地将下溢值设置为零而不指示错误。这在大多数情况下会导致严重的准确性损失（的确，这是丢失了\ *所有*\ 有效数字），并且浮点运算的基础假设已经被打破，因此当发生下溢时，程序员应该得到通知说下溢出发生了。仅在某些情况下，比如当结果稍后被加到很大的一个数字上时，将结果设置为零才合适。

要理解这样做的原因，请想象应用程序有可能产生太大或太小的超出范围的数字。
Posit 算术返回一个数值有 maxpos 或
minpos量级，后面就应该程序员决定如何处理。
这意味着此类情况的处理是在源代码中可见，例如

.. raw:: latex

   \diilbookstyleinputcell

.. code:: mathematica

   if (x = minpos || x = -minpos, 0, x);

换句话说，如果程序员更喜欢这样计算下溢，就应该自己明确地将小结果替换为零。
其实程序员很少有这样的。
对于程序员来说更为罕见的是会喜欢计算机在下溢的情况，只能使用汇编语言去访问唯一的隐藏在处理器中的标志！
三十多年来，IEEE 754
标准迫使硬件工程师将标志放入处理器寄存器中，希望流行的计算机语言能够以某种方式使它们可见。
这从来就没有发生过。

任何数据类型中的异常值都会增加硬件复杂性，并且还会增加能耗。 posit
格式的例外情况比 float 少得多。 在 64
位表示中，浮点数有\ *千万亿*\ 个比特串模式来表示“非数字”(NaN) ，而
posits 使用这些比特串模式来表示真实数值。
如果用户对Posit数要求负数的平方根、零除以零等，计算机语言应该捕获它并报告它（如果这是在语言规则中）。
如果某种原因它通过语言的保护，来实际尝试诸如 0 / 0
之类的事情，则默认行为是生成\ :math:`\pm\infty`\ 的
posit数并继续计算，浮点算术称之为“安静NaN”。
这避免了声明结果不可表示为数字，然后……\ *又将其表示为数字*\ 的逻辑矛盾。
它还避免了在开始算术运算时硬件测试NaN的任何需要，因为NaN不可能是输入。
没有表示它的位串。\ :math:`\pm\infty`\ 值履行“安静NaN”的角色。
计算机语言应该防止出现以下情况，

:math:`\pm\infty+\pm\infty`

:math:`\pm\infty-\pm\infty`

:math:`0 \times \pm\infty`

:math:`\pm\infty \times 0`

:math:`0 \div 0`

:math:`\pm\infty \div \pm\infty`

如果出现了，我们让\ :math:`\pm\infty`\ 作为安静的 NaN 指示器。
它是所有错误的垃圾场，我们可以将其视为“四舍五入到无穷大”。
请记住，即使非常大的数字在Posit算术中也不会舍入到无穷大，因此得到\ :math:`\pm\infty`\ 结果意味着您做了数学老师告诉您永远不要做的事情之一，比如除以零。
此策略在某些情况下非常有用，例如需要处理完成数字数组并且可以丢弃引发异常的情况。
有时输入数据无法输入，因此值完全未知，但我们不想因为偶尔出现丢失而停止计算。
这就是你需要一个安静的 NaN 的时候。

有些人可能会反对，“但是负数平方根的例外是不同的，我需要不同的行为！”
想想这意味着什么：一个程序要尝试计算负值的平方根来得到实数结果。
这是硬件应该尝试优雅地处理的事情吗？ 当然不是。 这是一个错误。
程序员需要首先阻止这种情况的发生。 代码中有问题的行

.. raw:: latex

   \diilbookstyleinputcell

.. code:: mathematica

   y = sqrt (x)

应该被修改成

.. raw:: latex

   \diilbookstyleinputcell

.. code:: mathematica

   y = if (x >= 0,(*then*)sqrt (x),(*else*) reportsquarerooterror (x))

或者sqrt(x) 函数的定义在特定语言和计算环境中产生错误消息并停止。
如果将错误处理委托给调用操作系统的中断，则意味着\ *不同的系统上会有不同的行为*\ 。
下一个反对意见通常是“但是条件语句会减慢我的代码速度！”
回答跟前面的一样，到底是应该硬件来全速处理编程的错误，还是程序员应该找出可能发生异常的地方，并通过明确的指示要做什么来做好保护。
显然是后者。
要求硬件始终留意错误并生成有关所发生情况的详细信息，就像在编译程序时打开调试模式，然后要求调试模式能以发布版本那样全速运行而没有性能损失。有经验的程序员会认识到这种需求的愚蠢。

valid模式具有更丰富的信息方式将运算结果表示为集合（包括空集），并且即使数学家宣布结果\ *不确定*\ ，也可以继续计算。
Posit是为了速度、简单性和经济性而设计的，这对于许多计算机用户（例如玩视频游戏的人，或使用浮点数在数值计算实践中似乎已经足够好的的人）来说，速度是最重要的。
对于那些关注严格计算（对结果设置界限并跟踪任何准确性损失）的人，或者那些仍在调试计算算法的数值行为以确保其能正常运行的人来说，valid模式就是答案。

.. raw:: html

   <table border="4">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightyellow">

当前的 IEEE 754
定义试图将速度和合法性这两种美学结合起来，这意味着它两者都没有实现。
“几乎正确”在数学上与“错误”相同。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

例如，各种舍入模式被吹捧为一种检查算法对舍入误差的敏感性的技术，但该技术仍然无法保证合法性，并且增加了电路的复杂性。
同样，“负零”有时被视为负无穷小的某种指示符，而有时它只是零，这为硬件设计人员带来了更多的复杂性和门延迟，但对其用户来说几乎没有什么价值。
