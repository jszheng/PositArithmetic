
Posit与IEEE浮点数的对比：基于度量的研究
=======================================

为什么Regime比特增加了精度
--------------------------

显然，状态位是一种“超级指数”，与浮点数相比，它放大了posit的动态范围。
而不太显而易见的是，它们还通过允许“剩余”更多位来表达数字的小数部分来\ *提高准确性*\ 。

举个例子，假设我们有 16 位并希望表达数字 10000。半精度 IEEE 浮点数（5
位指数字段）可以做到这一点而无需舍入：

.. figure:: assets/image-20230714113939885.png

   image-20230714113939885

浮点表示的
:math:`10000 = 2^{13}\times (1+\frac{113}{512})`\ 。这意味着我们需要一个指数范围达到\ :math:`2^{-14}`\ 到\ :math:`2^{14}`\ 的正则化浮点数，器指数至少需要5比特。而如果我们用16比特posit来表示的话，看看\ :math:`2^{13}`\ 可以用不同的es长度表示是什么样子，为了清晰就先不显示小数位。

.. figure:: assets/image-20230714125026049.png

   image-20230714125026049

这些都是将整数 13 表示为位移位（按 2 的幂缩放）的方法。
表达该整数所需的regime位数一开始每步下降为大约一半，然后当它达到最小两位
10 模式时，指数位就开始接管工作，总数线性增加 。
因此，当我们打算处理幅度接近 10000 的大量数据，则存在一个“最佳点”。 只有
es=3 或 es=4 才留出更多位给小数来准确表示 10000：

.. figure:: assets/image-20230714125752517.png

   image-20230714125752517

而对于es=3,
动态范围远远超过16bit浮点能表示范围，可能对于大多数低精度的应用来说都是

过头了。

.. figure:: assets/image-20230714130011317.png

   image-20230714130011317

如果有人想要对摩尔量进行低精度快速的化学计算，这已经足以很好地表示阿伏加德罗数了！

.. figure:: assets/image-20230714130122292.png

   image-20230714130122292

如果有人在现场可编程门阵列 (FPGA) 中将 posit
算术用于特定的嵌入式应用，而该应用（例如信号处理或机器学习）不需要与标准存储格式兼容，则没有理由限制
posit 不能是 - 比如说 23
位宽度且es为6。但是，我们希望尽可能轻松地从过时的 1985
年浮点格式标准过渡，这意味着需要标准化 16-、32-、64-、128-、 和 256-
位posit格式。 一位雄心勃勃的硬件工程师可能会使 es
值可配置，但随之而来的问题是程序语言对许多不同数据类型的支持。理想情况下，多年前编写的使用
float 和 double 关键字的 C 程序可以简单地重新编译为使用 32 位和 64
位posit，并使用不同的数学库（libm.h
包含文件），然后一切都应该正常工作。并产生更准确的答案。

我们需要匹配IEEE浮点的动态范围吗？
----------------------------------

在当前（2008）版本的 IEEE 754
标准中，有五种二进制浮点大小：16、32、64、128 和 256 位。
对于某些用户来说，在动态范围方面希望posit的表现与浮点数一样好甚至更好可能很重要，以免他们看起来为了准确性而牺牲了动态范围。

下面是 IEEE 浮点数和相同大小位置的表格，选择 es 是为了使 16 和 32
位大小的动态范围更好，并且对于 64、128 和 256 位大小几乎同样大。
如果要将 16 位和 32 位位置分别用作 32 位和 64 位浮点的替代品，那么提高
16 位和 32 位位置的动态范围可能很重要。

.. figure:: assets/image-20230714131332568.png

   image-20230714131332568

这些浮点数的指数大小不遵循任何数学模式，但反映了 IEEE
委员会激烈争论的妥协方案。 试图匹配 IEEE 委员会 1985
年时代的选择会导致一组同样令人费解的 es 值。
坦率地说，如此巨大的动态范围的原因是他们试图节省晶体管，而不是提供用户真正需要的东西。
浮点数的乘法和除法只需要指数字段的整数加法和减法，但小数字段则需要整数乘法器，其成本几乎可以与分数位数的平方成正比。
因此，虽然在实际应用中几乎没有人会超出 :math:`10^{-13}` 到
:math:`10^{13}` 的范围，但 IEEE 754 标准却自豪地允许您跨越从大约
:math:`10^{-78984}` 到 :math:`10^{78913}` 的范围。
即使是天体物理学家也不知道如何处理如此巨大的动态范围。
讽刺的是，无论这些决策者在整数乘法器的大小上节省了什么，他们都用一长串消耗大量逻辑的繁重异常情况来弥补（例如负零、次正规异常、NaN
和无穷大位模式，
多种舍入模式，以及对上溢、下溢和不精确结果的处理器标志的要求）。

目前我们还是假设 IEEE 的选择是合理的。 posit
表达2的幂次的方法在很宽的范围都可以为小数释放更多的位，下面是上述 es
的选择能提供的最大精度：

.. figure:: assets/image-20230714132756256.png

   image-20230714132756256

因此即使我们接受了IEEE 754
的为晶体管压缩做的选择，posit在准确性方面也很容易击败浮点数。

如果我们采取更合理的方法，每次将精度位数加倍时简单地增加 es 值会怎么样？
每一次这样的增量都会导致动态范围增加四倍，这当然应该是足够的。 为了与 8
位posit进行比较，让我们想象一个具有 3 个指数位的“四分之一精度”IEEE
浮点数，以便我们可以将该大小包含在表中一起对比。

.. figure:: assets/image-20230714133118900.png

   image-20230714133118900

如果我们不尝试匹配 IEEE 的超大动态范围并简单地使用 0-1-2-3-4-5 作为 es
大小，则下表是posit数的精度优势。

.. figure:: assets/image-20230714133225224.png

   image-20230714133225224

不知何故，这看起来更加理智。 请注意，对于 32
位位置，四个额外的精度位将使它们与 20 世纪 60 年代 IBM 推出其 System 360
之前的老式 36 位浮点数相当。 需要一些时间才能从 HPC
社区获得足够的反馈来决定这个问题，但现在我投票支持第二组 es 设置。 es
值应该选择

.. math::


   es = log_2(nbits)-3

附注：标准中最终选择es一律为2，统统为2。

构建低精度集进行比较
--------------------

让我们构造一些遵循 IEEE
规则的8bit的“四分之一精度”浮点数，然后构造一个具有可比动态范围的8bit的posit。
我们使用如此低的精度，以便可以实际找到整个值集并使用由它们对组成的表，该表将有
65536 个条目。 以下是四分之一精度 IEEE 样式浮点数的样子（使用 4
位指数，而不是上一节表中使用的 3 位指数）：

.. figure:: assets/image-20230714133725702.png

   image-20230714133725702

将 float 环境设置为具有 4 位指数字段的 8 位长：

.. raw:: latex

   \diilbookstyleinputcell

.. code:: mathematica

   setfloatenv[{8, 4}]

**floatfix**
函数将浮点强制看做整数作为输入，调整两组整数，从而将位字符串表示的浮点数按其值增递顺序排列。

.. figure:: assets/image-20230714135826433.png

   image-20230714135826433

float8 列表是由每种可能的位模式表示的浮点集。 使用 TableForm
打印列表是一个技巧，可以使分数自动以比整数更小的字体排版。

.. figure:: assets/image-20230714135854692.png

   image-20230714135854692

该集合有 256 个元素，但其中 14 个元素表示 NaN（不确定）。
另请注意，由于“负零”，值 0 在上述集合中出现了两次。 浮点数的最小正值为
1/512，最大值为 240，这使得它们的动态范围约为 5 个十进制。

现在构造 nbits=8 的posit。 如果我们选择 es=1，请注意 minpos 和 maxpos
的值超出了浮点数的动态范围：

.. figure:: assets/image-20230714140141910.png

   image-20230714140141910

再次生成表格，就像我们有 2 的补码整数，从最大负数到最大正数一样。
positfix 函数会像 floatfix 那样进行调整，将 posits 按升序排列。

.. figure:: assets/image-20230714140512577.png

   image-20230714140512577

对于Posit来说，\ *不存在*\ 浪费的情况。 所有位模式都代表独特的数学量。
这与 IEEE 浮点数的另一项数学违规有关。 如果
:math:`a=b`\ ，那么对于任何函数 :math:`f`\ ，我们期望
:math:`f(a)=f(b)`\ 。 但 IEEE
规则声明正零和负零在数值上相等，这让我们陷入了困境，但又说 1/x
对于“负零”来说是 :math:`-\infty`\ ，对于“正零”来说是 :math:`+\infty`\ 。
” 这意味着负无穷与正无穷相同。 呃…

对于Posit来说，\ *不存在*\ 浪费的情况。

“十进制精度”的仔细定义
----------------------

就像数值分析中的许多事情一样，我们已经习惯了一些被广泛接受但逻辑上相当草率的概念。
我们衡量各类“误差”的方式就是这样一个概念。
例如，这是一个被广泛接受的定义：

.. math::


   绝对误差= |X_{computed}-X_{exact}|

乍一看这似乎很有道理； 如果值相同，则它们的差异为零并且没有错误。
但是如果计算生成 315 而不是 314，那么该错误看起来与返回 3.15 而不是 3.14
非常相似吗？
为实数设计的数字系统通常跨越数十个数量级的动态范围，简单地相减看起来更像是用整数或定点方式看待不准确性。

为了修复这个矛盾，计算值的相对误差通常定义为

.. math::


   相对误差=|\frac{X_{computed}-X_{exact}}{X_{exact}}|

以下是您对此定义不满意的几个原因。 其一，如果在正确答案为 100 时计算
-1，则相对误差仅为 1.01。
如果您甚至不知道结果位于投影实数圆的哪一半，那么您基本上对答案\ *一无所知*\ ，因为符号是数字中最重要的部分。
在这种情况下，错误公式应该拒绝起作用。
甚至宣称相对误差为无穷大也太奉承了。

另一方面，数字及其倒数的公式完全不同。 假设\ :math:`x_{computed}=0.001`
但\ :math:`x_{exact}=0.0001`\ 。 那么相对误差是
9。但是，如果我们计算数字的倒数，则相对误差将以
:math:`x_{computed}=1000` 和 :math:`x_{exact}=10000`
作为输入，上面的公式可以保证我们发现相对误差仅为0.9。
仅仅通过取倒数就可以使答案看起来更准确，这是没有意义的。
如果您知道一辆汽车的每加仑英里数，相对误差为
0.1，那么您知道同一辆车的每英里加仑数，相对误差为
0.2，您不会感到困扰吗？
这就是为什么更常见的是说某件事精确到某个百分比，例如“百分之五以内”，这当然更好，因为它引用的是比率而不是差异。

工程师们在将数字与比率进行比较时一直有一个解决方案，那就是使用分贝。
比率 10 表示 10 分贝 (dB)。 比率为 1 dB 意味着比率为
:math:`10^{1/10}=1.2589\cdots`\ 。
与分贝一样，我们应该查看数字对数的差异，这与它们比率的对数相同：

.. math::


   \text{decimal error} \equiv | log_{10}(X_{computed})-log_{10}(X_{exact})| =|log_{10}(\frac{X_{computed}}{X_{exact}})|

注意，绝对值使得 :math:`X_{computed}` 和 :math:`X_{exact}`
在上面的定义中可以互换。 另外换用\ :math:`\frac{1}{X_{computed}}` 和
:math:`\frac{1}{X_{exact}}` 作为输入，也会产生相同的结果。
所以这看起来像是一个数学上合理的定义。

我们可以用任何对数为底来实现这些属性，但我们选择以 10
为底，因为它测量的是十进制数量级的误差，这与我们测量动态范围用的对于人来理解更友好的方式相同。
回想一下上面的例子，\ :math:`x_{computed}=0.001`\ ，但
:math:`x_{exact}=0.0001`\ ； decimal error 十进制数量级误差为
1，这意味着还十倍。

十进制数量级误差可用于定义十进制精度。 准确度是误差的倒数。
如果我们想知道精确度的位数，我们再次取以 10 为底的对数。

.. math::


   \text{decimal accuracy} \equiv log_{10}(\frac{1}{\text{decimal error}})=-log_{10}|log_{10}(\frac{X_{computed}}{X_{exact}})|

下面是 Mathematica 函数，它使用上述公式，但也处理异常输入值。
如果任一输入为 NaN，则精度为 NaN。 如果数字符号相反，它也会生成 NaN。
否则，如果输入值相同，则精度为\ :math:`\infty`\ 。 如果只有一个输入为
:math:`\infty` 或只有一个输入为 0，则精度为
:math:`-\infty`\ ，因为在对数标度上，0 和
:math:`\infty`\ 都距离任何非零实数无限远 。
这就是为什么将大结果“舍入”为无穷大（上溢）或将小结果“舍入”为零（下溢）是一场灾难。

.. figure:: assets/image-20230714212208935.png

   image-20230714212208935

如果数字相差十倍，则准确度为零； 我们甚至不知道结果的数量级：

.. figure:: assets/image-20230714212225341.png

   image-20230714212225341

工程师应该喜欢这个定义的属性：如果答案偏差 1
dB，则以下是十进制数量精度：

.. figure:: assets/image-20230714212351524.png

   image-20230714212351524

如果答案偏差 0.1 dB，那么我们的精确度为 2 位小数； 偏差0.01 dB
表示精度为 3 位小数，依此类推。

我们还可以分析\ **数字系统**\ 的准确性。 我们只研究 float8
集合中的三个连续值：{15/16, 1, 9/8}。 我们知道

[15/16,31/32) 中的值四舍五入为 15/16。

[31/32,17/16] 中的值四舍五入为 1。

(17/16,9/8] 中的值四舍五入为 9/8。

如果我们碰巧有一个值正好是 15/16、1 或 9/8，那么小数精度就是无穷大。
在这些值之间，小数精度降至最低。

.. figure:: assets/image-20230714212749269.png

   image-20230714212749269

请注意两个最小值处的轻微不连续性；
这是因为几何平均值和算术平均值之间的差异。
尖点位于中间点，\ :math:`(15/16+1)/2=0.96875` 和
:math:`(1+9/8)/2=1.0625`\ ，但这些不是定义为对数距离的小数误差最小化所在的位置。
该点将发生在 :math:`\sqrt{(15/16)*1}=0.96824\cdots` 和
:math:`\sqrt{1*(9/8)}=1.0606\cdots`
处，在这种极低的精度下，这是一个足够大的不连续性勉强可以看出。 在 16
位或更高的精度下，您实际上无法看到它。
如果计算量不是那么大，所有舍入应该是根据结果落在几何平均值而不是算术平均值的哪一侧来判断会更好一点。

但请注意，如果舍入位是指数位，则假定使用几何平均值进行舍入。
这种情况只发生在范围的极端处，但它有助于提高小数精度。
例如，在此处检查的 8 位posit集合，三个最大的正实数是 512、1024 和
4096。以下是该范围内 x 的位置小数精度：

.. figure:: assets/image-20230714214127152.png

   image-20230714214127152

512 和 1024 的几何平均值为
:math:`724.077\cdots`\ ，但小数部分的正常线性舍入使用中点 768
作为切换点，从而创建微妙但可见的不连续性。 另一方面，1024 到 4096
之间的几何平均值恰好是 2048，这也是 posits 用于切换点的值。
下面是正posit数的十进制数量级精度图：

.. figure:: assets/image-20230714214546832.png

   image-20230714214546832

锥形的精度非常明显。
最常见的数字位于可能指数范围的中心，精度最高。下面是测试的 8
位浮点数的十进制数量级精度图：

.. figure:: assets/image-20230714214926137.png

   image-20230714214926137

动态范围明显小于posit数，并且仅在左侧发生denormal才开始逐渐减小精度。

这些图表全面地显示了整个数字系统在动态范围内的准确性，但精确点处的垂直尖峰使得很难比较两个系统。
那让我们持悲观态度，看看数字集中每个点的最坏情况精度。
下图仅显示了每个波谷的底部，使我们能够在同一图上显示posit和浮点的精度：

.. figure:: assets/image-20230714215413547.png

   image-20230714215413547

在更高的精度下，锯齿状不太明显，并且posit的decimal精度是一个对称的三角形轮廓，在中心达到峰值；
浮点模式始终形成一个矩形，左侧有一个非规范化浮点的斜坡。
Posit比浮点在中心的位置有更高的精度，并且在下溢和上溢区域附近精度较低。
es
值越大，描述posit精度的三角形就越宽，并且在某些时候它变得如此宽，以至于整个精度曲线的精度低于浮点数。

对于 8 位 posits 和 float，posits 对于绝对值在 1/4 到 4
之间的数字具有较高的精度，对于绝对值在 1/16 到 16
之间的数字具有相同或更高的精度。

Morris浮点
----------

我们现在有足够的数学机制来展示 1971 年锥形精度方案发生了什么。
大约半个世纪前，罗伯特·莫里斯在他的论文《锥形浮点：一种新的浮点表示法》中提出了这一点。
值得去研究他的建议，并将其与posit数用上面提出的工具进行比较，特别是因为那些熟悉浮点数替代方案文献的人记得，早期曾尝试创建锥形精度数。
我们知道 Morris 方法从未流行过或影响到 IEEE 754 标准委员会。
也许我们可以弄清楚为什么没有。

Morris 建议添加一个附加字段，即 G 字段，用于描述指数有多少位。 G
字段中的位表示我们添加偏移量的整数，因此两比特 G 位可以表示大小为
1、2、3 或 4 的指数。或者它可以表示 3、4、5 或 6 .他描述了需要如下字段

-  G 字段表示指数位数
-  指数的符号位
-  指数位： E 字段
-  小数的符号位
-  剩余的 F 字段，就是小数字段，其中隐藏位始终为 1（无次正规数denorm）。

1971
年论文中声称，与仅具有带符号指数和带符号分数的系统相比，这可以为小指数值提供更多的精度位（小数位），但动态范围更大。
听起来很熟悉！
作者指出，在该系统中可以有多种方式来表示特定值（冗余位模式），并且他提出了这样的约定：使用
G 中存储最小的值的表示形式； 其他位模式在系统下变得毫无意义。

Morris 浮点数如下所示，有五个子字段：

.. figure:: assets/image-20230714221036607.png

   image-20230714221036607

注意我们仅在 G
位和指数符号位之间以及指数符号位和指数位之间显示黑色分隔线。
这提醒我们，其他分区位置根据G的内容而变化。

我们使用 :math:`nfbit` 表示标准浮点数中的位数，因此让我们使用
:math:`nmbit` 表示 Morris 浮点数中的位数。 我们可以使用 gs 作为 G
字段的大小，并使用 **setmorrisenv** 定义一个 Morris float 环境：

.. figure:: assets/image-20230714225348076.png

   image-20230714225348076

比如设定一个8位的环境，1 gs 比特

.. figure:: assets/image-20230714225454830.png

   image-20230714225454830

一个早期警告。 这个配置动态范围非常小。 事实上，如果我们使用 8
位来表示从 -128 到 127 的无符号整数，动态范围会更大。

现在我们需要 f2x 的等价物，我们可以将其称为
m2x，它遵循莫里斯指定的规则。

.. figure:: assets/image-20230714225708841.png

   image-20230714225708841

对于以下内容向读者致歉，但重要的是要看到简单地添加描述指数大小的字段所导致的混乱：

.. figure:: assets/image-20230715085837853.png

   image-20230715085837853

由有序位串表示的值的离散图为我们提供了有关莫里斯提案缺点的第二条线索：

.. figure:: assets/image-20230715085920846.png

   image-20230715085920846

这种格式的排序产生了多么疯狂的结果啊！
这就是莫里斯锥度精度方法的关键失败。
下面对值进行排序并去掉许多冗余表示：

.. figure:: assets/image-20230715090028916.png

   image-20230715090028916

8 位可以产生 :math:`2^8=256` 个不同的位模式。
而上面的列表中有多少个数学值？

.. figure:: assets/image-20230715090115992.png

   image-20230715090115992

应该有 256 个不同的值 …，但我们只有 161 个。Morris
系统散布着表达相同值的冗余方式，浪费了超过\ *三分之一*\ 的位模式。

以此作为数字系统，我们可以将小数精度与位置和传统浮点数一起绘制：

.. figure:: assets/image-20230715090244755.png

   image-20230715090244755

在最好情况下，莫里斯浮点可以匹配posit精度，但动态范围要小得多。
让我们至少证明，通过在 G 中允许两位而不是一位，Morris
浮点可以具有更大的动态范围（以各处精度非常低为代价）：

.. figure:: assets/image-20230716161358209.png

   image-20230716161358209

这是删除所有冗余后得到的结果：

.. figure:: assets/image-20230716162254947.png

   image-20230716162254947

现在，位模式的浪费更加严重，因为只有 145 个不同的值。

.. figure:: assets/image-20230716162356909.png

   image-20230716162356909

至少动态范围现在从 :math:`2^{-15}` 到 :math:`2^{15}`\ 。
但是，在定义浮点数的整个范围内，除了 1/2 到 4
之间的一小部分幅度之外，精度比浮点数还差，它设法维持相同的精度。

嗯… 如果我们为posit提供另一比特用于动态范围，会发生什么？

.. figure:: assets/image-20230716162816163.png

   image-20230716162816163

同样地来比较三个数字系统

.. figure:: assets/image-20230716185228311.png

   image-20230716185228311

这是一个字节大小的数字能表示的巨大动态范围！
posit数处处都与莫里斯浮点相匹配或更好。 跟IEEE
浮点相比，除了靠近上溢或下溢位置的区域外位置，也都有相同的精度。

这显示了设计好的数字系统以充分利用每个位模式具有的价值。
以低精度尝试所提出的系统是一个快速评估的方法，而用 32 位或 64
位表示评估时其缺点则很有可能被掩盖。

这很有趣，但对于接下来的部分，我们需要返回到 {8,1} 位置环境来与 8
位浮点数进行比较：

.. figure:: assets/image-20230716190712712.png

   image-20230716190712712

浮点和posit比较一元运算
-----------------------

倒数
~~~~

我们可以比较倒数闭包，即 1/x 可以精确表示为集合成员的情况的百分比。
比较浮点数或posit的倒数分别是：精确值、有限但不精确、和产生
NaN、上溢或下溢的整组的百分比：

.. figure:: assets/image-20230716191118553.png

   image-20230716191118553

只有 34 个浮点值具有精确的倒数。 相比之下，256 个 unum 值中的 48
个具有精确的倒数，并且不会因溢出而导致灾难性的精度损失。 IEEE
浮点定义是一个“拼凑”，因为它在低端是subnormal数（其倒数错误地溢出到无穷大），而在高端数字换成了
NaN 值。

下图可以更容易看出浮点和posit的相对性能。 整个集合计算 1/x
时的误差按从最小到最大的顺序排序并绘制。

.. figure:: assets/image-20230716192046096.png

   image-20230716192046096

posit数loss比浮点数增长得更慢，并且永远不会达到无穷大。

平方根
~~~~~~

我们还可以比较平方根闭包，即 :math:`\sqrt{x}`
可以精确表示为集合成员的情况的百分比。 **sqrtbarchart**
例程还找出平方根得出精确、有限但不精确或产生 NaN 的比例。
平方根运算不能上溢或下溢。 负输入产生 NaN 结果，但由于posit
的“:math:`\pm\infty`”实际上意味着无符号无穷大，因此\ :math:`\pm\infty`
的平方根是\ :math:`\pm\infty`\ ，因此对于该输入也是封闭的 。

.. figure:: assets/image-20230716193018044.png

   image-20230716193018044

posit表现较好，但乍一看优势不大。 条形图并未显示浮点数的不精确程度。
排序的误差图可以看出比计算 1/x 时的差异更大。 以下是每个非 NaN 的
:math:`\sqrt{x}`\ 值误差的排序图：

.. figure:: assets/image-20230716193644632.png

   image-20230716193644632

posit的误差比浮点小一半（对于有结果的数）

平方
~~~~

另一个常见的一元运算是
:math:`x^2`\ 。上溢和下溢是对浮点数求平方时常见的灾难。posit也会根据
IEEE 舍入规则会发生上溢或下溢，但至少损失只是几个小数而不是无穷大。

.. figure:: assets/image-20230716194321916.png

   image-20230716194321916

posit表现好很多，主要是没有那些异常情况

.. figure:: assets/image-20230716194455347.png

   image-20230716194455347

每个posit数都可以平方。
（无符号无穷大的平方还是无符号无穷大。）相比之下，几乎一半的浮点数平方会导致结果信息完全丢失。

对数（以 2 为底）
~~~~~~~~~~~~~~~~~

我们还可以比较以 2 为底的对数闭包，即 :math:`log_2(x)`
可以精确表示为集合成员的情况的百分比。 与平方根一样，大约一半的值会产生
NaN，因为负值的对数是复数。 注意：我们允许 posits
返回\ :math:`\pm\infty`\ 作为0的对数,
返回0作为\ :math:`\pm\infty`\ 的对数。 记无穷大是无符号的，就像零一样。

.. figure:: assets/image-20230716195104752.png

   image-20230716195104752

posit还是做得更好，乍一看，优势似乎很小。 但在 posit 环境中还有更多 2
的整数次幂，以 2 为底的对数可以精确表达。 以下是每个非 NaN
或无穷大值的误差排序：

.. figure:: assets/image-20230716195534400.png

   image-20230716195534400

posit误差又只有浮点的一半

指数（以 2 为底）
~~~~~~~~~~~~~~~~~

也许应该加一个\ :math:`2^x`\ 。如果你可以做\ :math:`log_2(x)`,
那么只需要一个缩放因子你就可以做\ :math:`ln(x)`\ 或是\ :math:`log_{10}(x)`
。类似地，当你可以做\ :math:`2^x`\ ，就可以容易地导出\ :math:`e^x`\ 或是\ :math:`10^x`\ 的缩放因子。

.. figure:: assets/image-20230716200506094.png

   image-20230716200506094

posit有一种例外情况：当参数为 :math:`\pm\infty` 时，结果为 NaN。
如果结果完全由无限值组成，我们能使用\ :math:`\pm\infty` 作为合法答案，但
:math:`2^{-\infty}` 为零，因此 :math:`2^{\pm\infty}`\ 是不确定的。

posit 的最大误差非常大，因为 :math:`2^{maxpos}` 将被舍入到 maxpos。
对此只有少数错误误差到了\ :math:`log_{10}(2^{4096})\approx 1233`
个小数位。
但是比较浮点哪个更糟糕：丢失超过一千位小数，还是丢失无限位小数？
好吧，如果您可以远离那些（罕见的）非常大的值，它仍然是赢的，因为较小值的错误对于posit来说表现得更好。
可以这样想：唯一一次在 posits
中出现较大的小数损失是在处理远远超出浮点数甚至可以表示为输入参数的数字时。

.. figure:: assets/image-20230716202249940.png

   image-20230716202249940

对于常见的一元运算
1/x、\ :math:`\sqrt(x)`\ 、\ :math:`x^2`\ 、\ :math:`log_2(x)` 和
:math:`2^x`\ ，posit一致地比具有相同位数的浮点数更准确，
并在更大的动态范围内产生有意义的结果。 精度越高posit的优势就越大。
如果我们要显示比较 32 位浮点与 32
位位置的一元运算的图表，它们将很难读，因为当需要当以足够大的比例绘制图表以显示浮点错误时，posit的误差将紧贴图的
x 轴！

现在，我们将注意力转向带有两个参数的四种基本算术运算：加法、减法、乘法和除法。

两参数的操作
------------

现在我们开始研究需要两个操作数的四个常规算术运算 + - \*/。
为了帮助可视化 65536 个结果，我们可以制作 256 x 256
的“闭合图”，一目了然地显示结果中哪些部分是精确、不精确、上溢、下溢或
NaN。

加减法
~~~~~~

因为 :math:`x-y=x+(-y)`
在浮点数和posit数中都可以完美工作，因此无需单独研究减法。
对于加法运算，我们精确计算出 z=x+y
结果，将其与每个数字系统规则返回的求和进行比较。
结果可能是精确的，或必须舍入到附近的有限非零数，或上溢出或下溢，或是像\ :math:`\infty-\infty`\ 产生
NaN 。 每一个都用颜色编码，因此我们可以一目了然地查看整个加法表。
在舍有入情况下，颜色编码是从黑色（精确）到洋红色（posit或浮点的最大误差）的渐变。
以下是 float 和 unum 的闭合图。 首先是浮点数：

.. figure:: assets/image-20230716203823561.png

   image-20230716203823561

.. figure:: assets/image-20230716203851517.png

   image-20230716203851517

由于输入中的所有 NaN 将以 NaN 为结果，边框框架都以黄色显示。
如果仔细观察左上角和右下角，您会看到将\ :math:`\infty`\ 加到\ :math:`-\infty`\ 以及将\ :math:`-\infty`
加到\ :math:`\infty`\ 的额外的 NaN 结果。

大的正值或大的负值的结果会溢出到\ :math:`\infty`\ 或\ :math:`-\infty`\ ，但加法运算符不会发生下溢。当输入的量级差异很大时，误差会从洋红色渐变为黑色，因为在这种情况下，小数精度的损失非常小。

这是posit的闭合图及其汇总表：

.. figure:: assets/image-20230716204800155.png

   image-20230716204800155

.. figure:: assets/image-20230716204841259.png

   image-20230716204841259

注意到的第一件事是求和精确的黑色区域比浮点数大得多。
那些区域中，是大小相似但符号相反的posit数，从而导致数字抵消。当幅度接近动态范围的中心时，抵消数字会产生较小的幅度数字，需要更少的小数位来准确表示。锥形精度正是在这些情况下想要的，并且这些情况在posit上比浮点数更常见，因为位置在动态范围中心附近有更多的小数数字。

初看起来没有 NaN 情况，但在最左下角确实有一个琥珀色方块，代表将
:math:`\pm\infty` 加上 :math:`\pm\infty`\ 时发生的情况。
上溢的可能已被消除。

以下是浮点数与定点数的加法性能总结：

.. figure:: assets/image-20230716205631449.png

   image-20230716205631449

精确求和运算的发生率更高是显而易见的。
与单操作数函数一样，我们可以对小数误差进行排序，并绘制图表来比较浮点加法与正加法的精度损失：

.. figure:: assets/image-20230716205721200.png

   image-20230716205721200

为了清楚起见，该图仅绘制了 65536 个误差中的前 64000 个误差。
如果绘制整个集合，最后几个posit加法案例的小数误差高达
0.3，但只有在表达远远超出浮点数动态范围的数字时才会发生这种情况。

.. figure:: assets/image-20230716210030086.png

   image-20230716210030086

最坏的情况是如果 maxpos+maxpos 四舍五入到 maxpos，则小数误差为
:math:`log_{10}(2)=0.3`\ 。 IEEE
将结果“舍入”为无穷大，从而产生无限小数误差。

乘法
~~~~

我们使用类似的方法来比较浮点和posit乘法的效果。
与加法不同，乘法可能会导致浮点数下溢。 “gradual underflow
逐渐下溢”区域提供了一些保护，正如您在闭包图的中心看到的那样。
如果没有非标准化浮动，蓝色下溢区域将是完整的菱形。

.. figure:: assets/image-20230716210445694.png

   image-20230716210445694

.. figure:: assets/image-20230716210525630.png

   image-20230716210525630

posit乘的颜色要少好多，这是一件好事。 只有两个像素亮起为
NaN，紧邻轴具有“零”标签的位置。 这就是 :math:`\pm\infty` 乘以 0 的地方。

.. figure:: assets/image-20230716210609747.png

   image-20230716210609747

.. figure:: assets/image-20230716210757326.png

   image-20230716210757326

浮点比posit有更多的准确值，但成本却很高。
如图所示，几乎四分之一的浮点乘积会上溢或下溢，并且对于更高精度的浮点，该比例并不会减少。

.. figure:: assets/image-20230716210929455.png

   image-20230716210929455

最坏情况的 posits 舍入发生在 maxpos \* maxpos 中，它会舍入到 maxpos。
这个点意味着（非常罕见）损失约 3.6 个小数。
如下图所示，与浮点数相比，posit在最小化乘法误差方面要好得多：

.. figure:: assets/image-20230716211056754.png

   image-20230716211056754

除法
~~~~

类似地，我们可以比较除法运算的闭包。
它几乎是乘法图的另外一种象限的排列。

.. figure:: assets/image-20230716211218951.png

   image-20230716211218951

.. figure:: assets/image-20230716211240370.png

   image-20230716211240370

情况与乘法类似；
精确结果的情况比posit的情况要多一些，但几乎四分之一的情况会发生灾难性的上溢或下溢。
请注意，posit闭包图看起来更接近于从左上角到右下角的对角线对称：

.. figure:: assets/image-20230716211437625.png

   image-20230716211437625

.. figure:: assets/image-20230716211456864.png

   image-20230716211456864

两个 NaN 值在左下角\ :math:`\pm\infty/\pm\infty` 和中心 :math:`(0/0)`
可见。 以下是除法比较的总结：

.. figure:: assets/image-20230716211600351.png

   image-20230716211600351

排序错误的图几乎与乘法的图相同，因此这里无需重复。

求幂
~~~~

让我们尝试比较 :math:`x^y` 操作的闭包。
这比标准的双参数算术运算计算起来要困难得多，而且许多结果都是复数值，因此会变成
NaN。 另外，\ :math:`0^0` 和 :math:`1^\infty` 都是 NaN。
图案奇异而壮观：

.. figure:: assets/image-20230716211816304.png

   image-20230716211816304

.. figure:: assets/image-20230716211849327.png

   image-20230716211849327

posit闭合图同样发人深省。
一般来说，负实数的负实数次方具有虚数部分，因此会触发浮点值和正posit值的
NaN，在左侧创建一个大的金带。 但也有例外，例如指数为负偶数时。
在图最左下角和左上角，所有posit都是负偶数。

.. figure:: assets/image-20230716212251357.png

   image-20230716212251357

.. figure:: assets/image-20230716212306707.png

   image-20230716212306707

请注意，\ :math:`0^0` 是 NaN，每个图的中心都有琥珀色方块。
浮点方块更大，因为它有两种零，因此有四种方法可以落在 :math:`0^0` 上。
以下是幂函数比较的总结：

.. figure:: assets/image-20230716212334728.png

   image-20230716212334728

排序错误的图最终会变得非常高，但是对于非 NaN
且不是很大或不是很小的值的区域， posits
会有通常的精度改进，尽管左侧有一个小区域，其中浮点数稍微更精确些取得了“领先”。

.. figure:: assets/image-20230716212559127.png

   image-20230716212559127
