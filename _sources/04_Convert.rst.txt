
将数值转换为Posit
=================

构建 x2p 转换函数
-----------------

将任何实数转换为Posit表示的方法与将任何类型的数字转换为浮点数的方法非常相似。
检查异常情况后（对于 posits 只是 0 和
:math:`\pm\infty`\ ），该数字除以二或乘以二，直到它位于区间 [1,2)
中，然后就可以确定小数。在 posits 的情况下，useed
是一种2的幂次的“批量”形式，因此我们首先除以useed
或乘以useed，直到它位于区间 [1,useed) 中。
然后将该值重复除以2，直到其位于区间 [1,2) 内，从而确定指数。
指数始终是非负的，从而无需偏移。该小数始终在二进制小数点左侧有一个前导 1
位，从而无需处理在二进制小数点左侧具有 0 位的subnormal 值。

该方法可用于转换定点数、整数、浮点数或任何其他可以重复乘以或除以 2
的类型，直到其在 [1,2) 范围内。 在 Mathematica
中，值是通用的“numeric”值，我们只需要在允许的数字类型集中包含无限大小的值，以确保可以将其转换为posit。
如果 **positableQ** 函数的参数可以转换为 posit，则返回 True，否则返回
False。

.. figure:: assets/image-20230714092834057.png

   image-20230714092834057

下面的代码是将一个实数转换为posit格式的函数

.. figure:: assets/image-20230714092950502.png

   image-20230714092950502

**x2p** 函数代码的方式旨在可以将其轻松转换为 C
语言的低级操作或芯片电路。 当您看到像“:math:`p=2p + 1`”这样的行时，在 C
中最好将其表示为 “p = (p<<1) \|\| 1”； 在 Mathematica 中，p =
BitOr[BitShiftLeft[p, 1], 1]
看起来太冗长，因此我们改用计算来编写实现相同的逻辑。

sigmoid函数
-----------

以下是 x2p 函数的一些可视化效果，也有助于测试其正确性。 首先以参数范围从
-maxpos 到 maxpos 生成的二进制补码整数图：

.. figure:: assets/image-20230714094023318.png

   image-20230714094023318

正如 Isaac Yonemoto
所观察到的，该图类似于机器学习深度学习神经网络所需的“Sigmoid”函数。
只需要缩放平移到 0 到 1
的范围。这种映射可以通过翻转posit的第一位，并将其右移两位来轻松实现的，可能需要四个晶体管，在处理器中很容易单个时钟周期完成
。机器学习社区目前有两种选择：它可以做计算带指数函数
:math:`\frac{1}{(1+e^{-x})}`\ ，那需要相当多的时钟周期：

.. figure:: assets/image-20230714094717184.png

   image-20230714094717184

… 或者，它还可以使用分段线性近似，这可能会导致训练的收敛问题。

这是用洋红色绘制的单周期低精度 posit 函数，用绿色绘制
:math:`1/(\mathbb{e}^{-x}+1)` 函数。 斜率在 :math:`x=0` 处匹配。

.. figure:: assets/image-20230714095234760.png

   image-20230714095234760

使用上划线运算符限制posit词汇
-----------------------------

最简单 posit 原型构造方法是让 Mathematica 来执行操作，但始终将支持 posit
环境的词汇区分开来。 我们可以定义overbar函数来为我们做限制。
将实数转换为最接近的posit，然后将其转换回实数以完成此操作；
此外，我们使它成为一个可以处理列表而不仅仅是单个数的函数，这将在我们进行线性代数时节省大量代码。

.. figure:: assets/image-20230714100044865.png

   image-20230714100044865

下面是我们如何在 {10,1} 环境中找到 :math:`\pi` 最接近的posit值：

.. figure:: assets/image-20230714100108328.png

   image-20230714100108328

将 Mathematica 视为没有舍入误差的“g 层”，而 overbar 运算符将我们带回“u
层”，其 unum 表示的精度有限。
事实证明，该系统作为posit计算环境的快速原型非常方便。

由于 x2p 和 p2x 近似为反函数，因此我们可以将 :math:`y=x` 的图与
:math:`y = \overline x` 进行比较，并获得与 :math:`y=x`
线纵横交错的阶梯函数。 它在从零到一的线性图上看起来相当不错：

.. figure:: assets/image-20230714100626181.png

   image-20230714100626181

测试 -minpos 到 minpos 之间的范围，以确保正确处理接近零的异常。
请注意，对于小数或下溢，没有“舍入到零”：

.. figure:: assets/image-20230714100843639.png

   image-20230714100843639

对于从 -maxpos 到 maxpos 的范围，使用双对数图使图形更易于阅读。
让我们实际上从 :math:`-2 \times maxpos` 到
:math:`2 \times maxpos`\ ，检查值是否不会“舍入”到无穷大（溢出）。

.. figure:: assets/image-20230714101449400.png

   image-20230714101449400
