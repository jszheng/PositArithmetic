
二次公式
========

我们可以举出书《错误终结：Unum 计算》中使用的示例，当 b
相当大时，使用二次公式 :math:`\frac{-b\pm\sqrt{b^2-4a c}}{2a}` 其中 b 比
a 和 c 大很多，导致两个根之一丢失有效数字。
使用的系数为a=3，b=100，c=2。

.. figure:: assets/image-20230716222227138.png

   image-20230716222227138

精确到小数点后九位的根是

.. figure:: assets/image-20230716222304679.png

   image-20230716222304679

问题是当 :math:`b^2` 远大于 :math:`a c`
并且平方根不精确时，一个根的相对误差会因相近数的相减而放大。
传统的数值分析教科书教导程序员应该使用重新排列代数的技巧。

.. raw:: html

   <table border="4">

.. raw:: html

   <tr>

.. raw:: html

   <td bgcolor="lightblue">

理想情况下，数字系统应该足够强大，以至于粗心的人可以使用它，而无需记住每种情况的技巧。

.. raw:: html

   </td>

.. raw:: html

   </tr>

.. raw:: html

   </table>

首先，使用单精度浮点数求根：

.. figure:: assets/image-20230716222611934.png

   image-20230716222611934

这是使用 posits 的相同计算： |image-20230716222648185|

使用橙色错误数字表示法可以更容易地看到精确度的比较：

.. figure:: assets/image-20230716222725483.png

   image-20230716222725483

顺便说一句，如果我们确实使用代数重排技巧，posit仍然会击败浮点数。
技巧是将 :math:`(-b+\sqrt{b^2-4a c})/(2a)` 写为
:math:`(2c)/(-b-\sqrt{b^2-4ac})` 以避免通过减法刮掉有效数字相似的数字。
与大多数数值技巧一样，它并非显而易见，必须通过繁琐的代数来计算，并且在编码时很容易出错。

这是使用浮点技巧计算的较小量级根：

.. figure:: assets/image-20230716223008565.png

   image-20230716223008565

当这个技巧与 posits 一起使用时，误差大约缩小了 8 倍：

.. figure:: assets/image-20230716223111485.png

   image-20230716223111485

对比如下

.. figure:: assets/image-20230716223141127.png

   image-20230716223141127

.. |image-20230716222648185| image:: assets/image-20230716222648185.png
