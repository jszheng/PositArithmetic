
融合的操作与Quire数据类型
=========================

“延迟舍入”概述
--------------

到目前为止，我们已经展示了 posits 如何成为 float 的直接替代品。
然而，它们的力量远不止于此。 将代码从 float 移植到 posits
后，如果改进的准确性仍然不够（例如尝试用 32 位 posits 替换 64 位 float
时），可以使用\ **quire**\ ，这是很简单并且可以大幅提高答案质量的方法。
在浮点环境中没有类似的东西，因为 IEEE 754
委员会三十多年来一直坚决拒绝将类似的东西纳入标准。

IEEE 754 标准的最新版本 (2008) 在其功能中包含了融合乘加。
“融合”是指通过在具有设定大小的暂存区域中使用精确整数算术执行所有操作，将舍入推迟到计算中多个操作的的最后一个。
它与扩展精度算术不同，扩展精度算术可以增加整数的大小，直到计算机耗尽内存。
posit 环境支持以下融合操作，使用称为 **quire** 的定点临时值。

融合乘加 :math:`(a \times b)+c` 融合加乘 :math:`(a+b)\times c`
融合乘乘减 :math:`(a \times b)-(c \times d)` 融合和 :math:`\sum{a_i}`
融合点积（标量积） :math:`\sum{a_ib_i}`

（顺便说一句，字典上“**quire**”是一个中世纪术语，指的是由固定数量的纸张或羊皮纸制成的小册子。）我们需要找出需要多少位
quire才够，以nbits和es作为函数.
注意到对于处理器硬件要求而言，上面列表中的所有操作都是融合点积的子集。

与所有 unum 环境一样，操作的融合必须是显式的，而不是隐蔽的。
如果一个程序员写

.. raw:: latex

   \diilbookstyleinputcell

.. code:: mathematica

   x := (a * b) + c

当所有变量都具有相同类型时，编译器设计者可能会想通过使用融合乘加来“帮忙”。
可能的结果是，程序员得到的答案与另一个编译器生成的答案不同，该编译器在乘法之后四舍五入，在加法之后再次四舍五入。
追踪这个问题可能会浪费很多时间来试图找出原因。 在 posit
环境中，您可以通过例程调用请求融合乘加：

.. raw:: latex

   \diilbookstyleinputcell

.. code:: mathematica

   x := FMA(a, b, c)

但是，声明一个 quire 变量可能更容易阅读并且使用更灵活，如下所示：

.. raw:: latex

   \diilbookstyleinputcell

.. code:: cpp

   posit a, b, c, x;
   quire q;
   q = (a*b) + c;
   x = q;

因为到 quire
中的乘法累加没有舍入误差，所以这与整数乘法加法一样可重复和可再现。
它更灵活，因为你也可以这样做：

.. raw:: latex

   \diilbookstyleinputcell

.. code:: cpp

   posit a, b, c, x;
   quire q;
   q = a*b;
   (*  Some other code can go here, like to compute c.  *)
   q += c;
   x = q;

然而我们远远超出了仅融合一个乘加的范围，而是允许融合一堆它们。
您可能认为这需要扩展精度的数学库和不可预测的存储量，但事实并非如此。
我们只需要限制我们可以进行的累积次数，而不会有溢出的风险。
事实证明，它可能是一个相当高的限制，特别是对于 32 位和 64 位posit数。

quire 方法是由 Ulrich Kulisch 在 20 世纪 70
年代引入的，当时晶体管太珍贵，以至于无法考虑将具有数百位的固定大小寄存器放入处理器中。
Kulisch
和他的同事开发了一套庞大而丰富的技术来进行大规模计算，其结果精确到\ *单个舍入误差*\ 。
他将存储称为“精确累加器”，但这有点拗口，我们更喜欢更简单的创造术语“quire”。
Kulisch 创建的所有技术都可以在 posit 环境中再次使用。

也许最大的惊喜是：使用 quire 可以使代码更快，而不是更慢。
而且不是一点点：Koenig 和 Biancolin 在伯克利 ASPIRE
实验室进行的最新硬件测试表明，quire 操作比每次操作后进行舍入快大约 3 到
6 倍。 如果一种方法使代码变得更快并且更准确，为什么有人不想采用它呢？

Quire 大小
----------

进行点积时可能出现的最小非零值是 :math:`minpos^2`\ 。 其他所有乘积都是
:math:`minpos^2` 的整数倍。 如果我们必须在暂存区域中执行向量
{:math:`maxpos,minpos`} 和 {:math:`maxpos,minpos`}
的点积作为精确运算，我们需要一个足够大的整数来容纳
:math:`maxpos ^2/minpos ^2`\ 。 回想一下 :math:`maxpos=useed ^{nbits-2}`
和\ :math:`useed=2^{2^{es}}`\ 。 另外，minpos=1/maxpos。 所以

.. math::


   \frac{maxpos^2}{minpos^2}=useed^{2\times 2 \times(nbits-2)}=2^{(4nbits-8)2^{es}}

一个长度\ :math:`(4nbits-8)2^{es}+2`\ 比特的定点无符号整数可以保存
:math:`minpos^2` 和 :math:`maxpos^2` 之和。 例如，对于 es=0 的 8
位posit，\ :math:`minpos` 为 :math:`2^{-6}=1/64`\ ，\ :math:`maxpos` 为
:math:`2^6=64`\ 。 因此，您需要二进制小数点右侧有 12 位，左侧有 13
位，才能将 :math:`maxpos^2+minpos^2=4096+1/4096` 保存为定点整数：

.. math::


   4096+\frac{1}{4096}=1000000000000.000000000001

我们还需要一位来表示符号。
但我们还需要在最坏的情况下允许一些进位，即加在一起的数字都是
:math:`maxpos ^2` （或都是 :math:`-maxpos ^2`\ ）。
如果我们总共容纳至少十亿个项，有时甚至更多，就不应该有太多抱怨了。
因此，在整数大小上添加 30 位。 （\ :math:`2^{30}` 略高于十亿：1 073 741
824。），为了更好地衡量，将其四舍五入到最接近的 2
的幂，这样硬件设计就干净了。 这是我们对 quire
大小的定义，\ **quiresize**\ ，posit大小从 4 到
256。（当我们定义valid模式的规则时，包含大小 4 和 8
的原因将变得更加清楚。）

.. figure:: assets/image-20230717093856626.png

   image-20230717093856626

通过这些，我们可以生成标准posit尺寸的表格：(这些在最新标准都有改变)

.. figure:: assets/image-20230717094059083.png

   image-20230717094059083

如果您将它们视为寄存器，长度是很大，但远小于 Mathematica
使用的扩展精度算术所需的大小。 现代处理器核心可能有 64 个通用 64
位寄存器； 占用其中 32 个可满足 64 位posit数的要求。

之前，我们提到过小至 8 位的假设对于机器学习来说就足够了。
即使乘法累加仅用 8 位存储也是如此。 看来对于 8 位posit的quire（大小仅为
64 位并且能够进行 25
万亿次累加而不会溢出）在此类应用中可能非常有用，也许可以提高收敛速度。

quire能做什么，不能做什么
-------------------------

程序员可能会想，“这些 quire 变量是如此安全和准确，我想我会将所有变量设为
quire 类型。” 别那么快。
您可以合理要求硬件执行的操作列表很短，并且不包括将quire乘以任何内容。
是为了累加操作。 假设一个核中只有一个quire寄存器。 汇编指令应包括

-  Clear 清除quire寄存器
-  Load 装入内存的数据到quire寄存器
-  Store 将quire寄存器数据存入内存
-  将两个posit乘积加到quire上
-  将两个posit乘积从quire上减去
-  将内存中一个quire数加到quire寄存器上
-  将内存中一个quire数从quire寄存器上减去
-  将quire转换为posit

由此，很容易在 quire 中构建像 :math:`a\times d-b\times c` 这样的表达式。
简单求和是乘以 1 的一种特殊情况，就像使用融合乘加硬件所做的那样。
如果您想将quire中的数字乘以某个值，则必须将其转换回posit数。
我不得不承认我很想在列表中再添加一条汇编指令，因为它非常有用：

-  把quire寄存器数做平方根，结果转换回posit数

这可以让你计算像 :math:`r=\sqrt{x^2+y^2+z^2}` 且只有一个舍入误差，结果 r
将与 x、y 和 z 中的最大值大致相同 而无须将 :math:`r^2`
临时存储在一个posit中，这可能会导致幅度太大或太小而导致准确性丢失。物理模拟充满了这种距离计算，而平方根算法是一种可以直接构建到硬件中的算法；
唯一担忧的是对于大型quire，该操作可能需要许多时钟周期来确定正确的舍入，从而使上下文切换需要在粗粒度上进行而产生一些困难。

我们不会在接下来的部分中明确地看到quire，因为我们可以在 Mathematica
中奢侈地使用足够精度，因为quire精确运算只是它内置扩展精度算术可以完成的操作的一小部分。
如果我们不在结果上加横线，则假定结果是精确的而不是四舍五入的。
我们只需限制将舍入推迟到上面列表的操作即可。
