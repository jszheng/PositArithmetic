
浮点数与Posit对比预览：32 比特下的准确性
========================================

在我们对posit和浮点进行一连串的比较之前，让我们进行一场赛前比赛。
如果我们评估表达式

.. math::


   \left ( \frac{27/10-e}{\pi-(\sqrt{2}+\sqrt{3})} \right )^{67/16}

正确到十位小数，即 :math:`302.8827196\cdots`\ 。 我们可以比较 32 位标准
IEEE 浮点数和至少具有同样大动态范围的 32 位Posit能达到的精度。

首先，尝试单精度浮点环境，根据 IEEE 标准，该环境使用 8 位作为指数：

.. figure:: assets/image-20230714111734081.png

   image-20230714111734081

IEEE 32 位浮点数的不平衡动态范围约为 83 个十进制：

对于计算中的每一步，Mathematica
类型的实数值都会转换为浮点数，这意味着它们通常会四舍五入。 accbenchf 和
accbenchp 函数不带参数，因为它们仅依赖于环境设置。
请注意下划线和上划线符号如何让我们编写看起来正常的方程，并显式地将每个结果舍入为
float 或 posit 数。

.. figure:: assets/image-20230714112004685.png

   image-20230714112004685

下面试试看IEEE 32比特单精度浮点的结果

.. figure:: assets/image-20230714112059039.png

   image-20230714112059039

IEEE 单精度给出的答案是
:math:`302.\color{orange}912 \color{black}\cdots`\ ，偏离了大约 0.0297。
我们使用将与代表正确答案的十进制数字不同的十进制数字着色为橙色的约定。
尽管单精度浮点数的标称精度约为小数点后七位，但在这个简单的表达式中，该精度很快就会消失，只剩下三位正确的数。

现在尝试一下。 下划线变成了上划线，并且分母 **tden**
的计算已推迟舍入，因为 posits 可以对 quire
中的一长串数字求和（稍后会详细介绍）。

.. figure:: assets/image-20230714112545290.png

   image-20230714112545290

让我们尝试一系列 es 值，看看最佳位置在哪里。

.. figure:: assets/image-20230714112627030.png

   image-20230714112627030

所有这些答案都比浮点答案准确得多！ 当 es=1
时，相同位数的posit答案有四个正确的小数，\ :math:`302.8827\color{orange}81\cdots`\ 。
该误差比浮点误差小了近 500 倍。当 es=3
时，动态范围达到浮点的两倍左右（144 个十进位而不是 83
个十进位），posit的数值精度仍然提高了约 74 倍 。

这个“32位的准确性”示例预览了为什么从浮点数切换到posit可能是值得的。
在许多应用中，32 位浮点可能不够准确，迫使程序员直接跳转到 64 位浮点。
如果 32 位posit可以实现更多小数点的精度，则程序可以允许使用 32
位变量，从而在带宽、存储以及移动数据所需的能量和功率方面节省 2 倍。

下一节将使用 float 规则和 posit
规则创建两个完整的数字集，并比较其对于基本算术的完整性表的性质。
