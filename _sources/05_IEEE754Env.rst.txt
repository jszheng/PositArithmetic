
创建IEEE 754浮点环境
====================

浮点环境的两个参数
------------------

我们可以对 IEEE 类型的浮点数执行与设置 posit 环境非常相似的操作。 然而与
IEEE 浮点数不同的是，我们可以提供非常灵活的大小的总位数 :math:`nfbits`
以及指数位数 :math:`esize` 。 小数中的位数 :math:`fsize`
是可以算出的常数，因为只有符号位、指数位和小数位总计为
:math:`nfbits`\ 。
简单数字转换所需的值包括指数偏差、最小次正规浮点subnormal、最小标准化浮点、最大有限浮点，以及向下舍入到最大有限浮点而不是溢出到无穷大的最大有限值maxroundable
。 （向上舍入到最小次正规的最小有限值是最小次正规的一半
minroundable；更小的值将下溢到零。）

.. figure:: assets/image-20230714102735764.png

   image-20230714102735764

例如，设置每个数字 6 位和 2 个指数位的环境：

.. figure:: assets/image-20230714102802584.png

   image-20230714102802584

下面就是计算出来的环境设置

.. figure:: assets/image-20230714102833609.png

   image-20230714102833609

我们可以独立指定 posit 环境和 float 环境。 变量名称不重叠。
这使我们能够使用浮点和posit对各种算法进行一对一比较的基准测试。

当浮点数只有一位指数位时，它们的行为很像定点数，因为所有有限值都是subnormal的。
这给 IEEE 规则带来了困难； 例如，maxfloat 变得比smallnormal
小，但是smallnormal 的位模式是IEEE 规定必须用来表示无穷大的一种！
解决这种疯狂问题的最简单方法就是要求 esize 为 2 或更大。
我们还需要符号位和至少一个小数位（否则无穷大值和 NaN 值之间没有区别）。
因此 nfbits 的最小可能值为 4。以下是 nfbits=4 的 16
种可能的位模式所表示的值，仅供娱乐：

.. figure:: assets/image-20230714103230471.png

   image-20230714103230471

将浮点数转换为Mathematica数值的函数：f2x
----------------------------------------

现在我们需要 **p2x** 的等价物，我们可以将其称为
**f2x**\ ，输入表示浮点数的位字符串（上表中的第一列）函数返回其数学值（第二列）。
由于有五个异常情况，该例程比 posits 更复杂，这也是 float 比 posits
消耗更多电路的原因之一：

.. figure:: assets/image-20230714103651274.png

   image-20230714103651274

其中 s = 符号位，e 是由指数位表示为无符号整数的整数，f
是分数，不包括隐藏位。 以下例程提取位字段，然后应用上述公式。

我们不能返回“正零”和“负零”，因为它们不是数学量。 根据 IEEE
规则，它们的倒数分别为正无穷大和负无穷大，但它们应该测试为彼此相等！
其他古怪的性格特征也被分配给这两种零，例如要求“负零”的平方根是“负零”。
毫不奇怪，这两个非数学量的处理是处理器中浮点处理单元 (FPU)
硬件设计错误的丰富来源。
在这里，我们只是将零分配给两种情况（数学上的零），但稍后在计算闭合图时，我们必须再次适应
IEEE 规则来适应这两个概念 ……是零, 从某种意义上讲。

.. figure:: assets/image-20230714104621118.png

   image-20230714104621118

数值转换为浮点
--------------

我们快完成了； 最后一步是创建 **x2f**\ ，这样我们就可以将值（可能是 NaN
或无穷大）转换为 IEEE 风格的浮点数。
“可转浮点”的值是实数、带符号的无穷大或 NaN（Mathematica
称之为“**Indeterminate**”）。 这是测试函数定义：

.. figure:: assets/image-20230714104835408.png

   image-20230714104835408

我们可以用它来防止转换函数做一些不应该尝试的事情。

.. figure:: assets/image-20230714104930039.png

   image-20230714104930039

使用 **colorcodef** 运算符来查看浮点数的位字段会很方便，就像我们对
posits 所做的那样。

.. figure:: assets/image-20230714105140387.png

   image-20230714105140387

前面我们将 **setfloatenv** 设置的浮点环境为 {6,2}。 现在让我们测试一下用
001101 表示的浮点数的颜色编码，在这个很小的浮点环境中，它代表 1.625：

.. figure:: assets/image-20230714105320566.png

   image-20230714105320566

对浮点数运算词汇的限制：下划线运算符
------------------------------------

正如我们定义了上划线运算符来限制计算使用posit数一样，我们可以定义下划线来将值限制为浮点数：

.. figure:: assets/image-20230714105644218.png

   image-20230714105644218

同样以\ :math:`\pi`\ 为例子，对于当前的{6, 2}浮点环境有

.. figure:: assets/image-20230714105746180.png

   image-20230714105746180

让我们做两个快速图形测试，就像为posit所做的测试一样。
首先做接近于零的图，包含了所有subnormal：

.. figure:: assets/image-20230714105933337.png

   image-20230714105933337

现在是从 1 到 maxfloat
的图表，我们使用双对数图来更好地显示变化范围内的锯齿形：

.. figure:: assets/image-20230714110204500.png

   image-20230714110204500

值得注意的是，对于 posits，x2p[p2x[p]] 返回 p
总是正确的，而对于浮点数，不可能用 x2f[f2x[f ]] 和 f 实现如此完美的逆。
“负零”和表示 NaN 的多种方式是问题所在。
