
可视化射影实数
==============

最小的posit，和useed
--------------------

与实数轴不同，射影实数将线包裹在一个圆上，所以负无穷大和正无穷大在顶部相遇。

有时，事物的发明方式并不是理解它们的最简单方法，这就是为什么我们首先在第
2 节中展示位字段，现在才展示它们的几何推导。 类型 III Posit算术源自类型
II unum，后者也将二进制整数映射到射影实数，但在类型 III
中，我们放宽了所有值都具有精确倒数的要求。 II 型和 III 型 unum
都以这个两比特的模板开头的：

.. figure:: assets/image-20230713160353886.png

   image-20230713160353886

围绕环外侧的 2
的补码格式的有符号整数与实数在完全相同的点处从正值绕回到负值。
这消除了“负零”； 不幸的是，它同时也把\ :math:`-\infty`\ 和
:math:`+\infty`\ 不再看成不同的量，但解决这点比处理两种形式的零要简单得多，这两种零有时被认为是相等的，有时被不同地对待，这就是
IEEE 浮点数的所做的。

上面的环虽然只有两位，但却代表了一个数字系统。 我们通过在 1 和
:math:`\pm\infty`\ 之间插入一个值来构成到三比特的数。
可以是大于1的某个实数； 可以是 2、或 10、或 :math:`\pi`\ 、或
1.00003、或 :math:`10^{100}`\ 。
选择就像在unum环上“播种”生长出更宽的数，因此我们将其称为“*useed*”。
我们遵循类型 II
规则，也就是垂直轴上镜像的点是相反的，水平轴上镜像的点是倒数。

.. figure:: assets/image-20230713162429381.png

   image-20230713162429381

下一步，我们应该在\ :math:`useed`\ 和\ :math:`\pm\infty`\ 之间放置么？
嗯，\ :math:`useed^2` 确实有效。
然后，我们可以通过将\ :math:`useed^{1/2}=\sqrt{useed}`
放在1和\ :math:`useed`\ 之间来获得一对优雅的新对称点，特别是如果\ :math:`\sqrt{useed}`\ 是一个非常适合计算机硬件的整数。
如果 :math:`\sqrt{\sqrt{useed}}` 也是整数，我们可以重复这个过程。

所使用的对计算机硬件友好的\ :math:`useed`\ 值有
:math:`2`\ 、\ :math:`2^2`\ 、\ :math:`(2^2)^2`
等，反复平方以确保我们可以反复求平方根并返回到 2。这个数列为 2 , 4, 16,
256, 65536, … … 。在 1 和 2 之间，我们可以线性填充环，即如果多一位，则为
{1, 1.5, 2}，如果多两位，则为 {1, 1.25, 1.5, 1.75, 2}，依此类推
，与浮点分数的工作方式完全相同。 从值 2 开始，平方得到使用的次数是
:math:`es`\ 。 这就是为什么\ :math:`useed=2^{2^{es}}`\ 。

**ringplot**\ 例程显示了表示排列在环上的射影实数的位置，其数学形式位于内部，颜色编码的二进制形式位于外部。
它使用任何 nbits 和 es 环境设置。
我们切换到旋转文本，这样我们就可以在空间中塞入更多值，尽管这使得阅读起来有些奇怪。
尝试 nbits=3 和 es=1：

.. figure:: assets/image-20230713170800383.png

   image-20230713170800383

如果环是指南针，则 +1为东，-1为西，0 为南，\ :math:`\pm\infty` 为北。
useed值始终位于罗盘的东北点。 对垂直轴进行镜像是该数字的负数。
绕水平轴镜像， 0、 :math:`\pm\infty` 以及所有 2
的幂次数可得到精确的倒数； 其他值得到的是近似倒数；在所有情况下，posit数
x 的水平镜像值的范围为 :math:`\frac{1}{x}` 到
:math:`\frac{1.125}{x}`\ 。

这些 unum 产生有递归的定义方法。 通过增加 nbits 来追加一位时，追加 0
不会改变值； 附加 1
在现有值中间的圆上创建一个新点，其代表的值遵循以下规则：

-  如果它位于 0 和 :math:`\pm 2^j` 之间的圆底部旁边，则新值比
   :math:`\pm 2^j` 小useed倍。（添加的位是regime位。）
-  如果它位于 :math:`\pm2^j` 和 :math:`\pm\infty`
   之间的圆顶部旁边，则新值比 :math:`\pm 2^j`
   大useed倍。（添加的位是regime位。）
-  如果它位于大小为 :math:`2^i` 和 :math:`2^j` 的两个值之间，其中整数 i
   和 j 相差超过 1，则新值的大小为 :math:`2^{(i+j)/2}`\ 。
   （添加的位是指数位。）
-  如果它在任何其他相邻点x和y之间，则表示(x+y)/2。（添加的位是小数位。）

引入指数位
----------

在环上添加新点的系统比听起来更简单。 检查 4 位位置的颜色编码；
指数位开始出现在环的东部和西部部分：

.. figure:: assets/image-20230713173616489.png

   image-20230713173616489

请注意，上一个环形图中的每个值都保持在原位，并在其表示形式后附加了 0。
新值位于先前的环形图的值之间，并以 1 位结尾。
这是这些数字的美妙特性之一； 当通过附加 0
位来提高精度时，它们会保持不变，并且通过附加 1
位创建的中间点会自动增加动态范围（顶部和底部）和精度（左侧和右侧）。

您可以注意到的另一件事是，前两位始终确定数字所在圆的象限。 与 II 型 unum
一样，将它们视为符号倒数位。 前两位是

-  00 在东南， :math:`0 \le x \lt 1`
-  01 在东北， :math:`1 \le x \lt \infty`\ ，
-  10 在西北，\ :math:`-\infty \lt x \lt -1`\ ，
-  11 在西南， :math:`-1 \le x \lt 0`\ 。

这也可能有助于解释硬件如何在不首先获取 2 补码的情况下解码regime位。

小数位出现
----------

下一步将我们带到五位宽的Posit数，然后完整的模式就会出现。
在圆的顶部和底部，添加一比特总是将动态范围扩大useed倍或是缩小useed倍。
在圆的右侧和左侧，添加一位现在总是为分数添加一位精度。
有了五位，我们现在看到小数位出现在射影实数圆的东部和西部。

.. figure:: assets/image-20230713213902547.png

   image-20230713213902547

如果增加 IEEE
浮点数的位数，则必须决定指数中增加多少位以及分数中增加多少位。 更改 IEEE
指数位数也意味着更改指数的偏移，因此一般来说，从一种 IEEE
精度转换为另一种精度是一件复杂的事情。 对于 I 型 unum 来说也是如此。
对于III型Posit来说就很简单：您只需在右侧添加位即可。
在位置末尾添加位可以增加环北部和南部部分的动态范围，以及环东部和西部部分的精度。
这表明可以很容易地随着计算的进行而来改变环境设置。

在上图中，请注意以小数位结尾的数字在其镜像中是没有完美的倒数的。
虽然接近但不完全是。 3/2的镜像是3/4，而不是2/3。 3 的镜像是 3/8，而不是
1/3。 用镜像作点为初始值迭代计算倒数是一个很好的起点。
通过将所有有限数限制为 :math:`2^m \times n` 的形式（其中 m 和 n
是整数），而放宽对于每个数字倒数都要是完美的要求，使Posit变得简单且硬件友好。

6位宽的环图
-----------

如果我们尝试6比特的Posit，其ringplot做出的图仍然可读

.. figure:: assets/image-20230713215404932.png

   image-20230713215404932

7位宽的环图有百万比一的动态范围
-------------------------------

将图形推到值几乎要重叠但仍然清晰的地步，具有 1 位指数字段的 7
位位置可以具有六个数量级的动态范围，而且\ :math:`\pm 1`
附近的点还有超过一位十进制小数的相对精度 。

.. figure:: assets/image-20230713220121343.png

   image-20230713220121343

也许这是一个很好的地方来指出舍入与浮点数的舍入有何微妙的不同。
如果舍入位是小数位，则它与浮点数完全相同。
四舍五入到最接近的值，如果存在平局，则选择以 0 位结尾的数字。
但假设计算结果在 64 到 256 之间；
我们决定向上舍入还是向下舍入的中点是多少？
注意到舍入位有一比特指数位，因此您要舍入到最接近的指数。
对于硬件来说，它与舍入小数位时的算法完全相同。 如果我们再多一位精度，64
和 256 之间的中点是 128。64 和 128 之间的数字四舍五入为 64； 128 到 256
之间的数字四舍五入为 256； 精确值 128 是平局，64 是以 0
位结尾的位置，因此 128 舍入为 64。

因此，除了异常值 0 和 :math:`\pm\infty`
附近的结果之外，舍入规则是一致的。 永远不会向那些极端值舍入。 而是改用
:math:`-minpos`\ 、\ :math:`minpos`\ 、\ :math:`-maxpos` 或
:math:`maxpos`\ 。 至少这还保留了答案的正确符号。

附注： 要自己尝试ringplot图，可以访问
https://cse512-19s.github.io/FP-Well-Rounded/

抢先预览：valid算术
-------------------

将环图一直保留到 7 位的原因之一是，上面的环图为 16
位\ **valid数**\ 奠定了良好的基础。
作为对强大的、无需猜测的算术世界的预览，valid数是一对posit，每个posit都有一个不确定位\ **ubit**\ ，附加到小数后，形成一个\ **tile**\ 。
Ubit 采用洋红色 (RGB 1, 0, 1) 进行颜色编码。 对于上面显示的所有值，ubit
均为 0，对于上面显示的值之间的所有开放间隔，ubit 均为 1。 一种可能的 16
位valid数格式是一对 7 位posit数，每个posit数末尾都有 ubit 位，如下所示：

.. figure:: assets/image-20230713221908557.png

   image-20230713221908557

（出于说明目的，我们再次使用通用 es 值。比特位数如此短的 es 值几乎肯定为
0。在上面的环图中，es 为 1。）

每个tile可以是上面 7 位posit环中显示的任何值，后跟
:math:`\color{magenta}0` ubit 或 :math:`\color{magenta}1` ubit。
传统的区间算术采用闭区间 [a,b] 的形式，其中 a 和 b 是浮点数，且
:math:`a \le b`\ 。 在valid的情况下\ *端点不需要排序*\ 。 lower
tile表示从环上的哪里开始；所表示的间隔包括从lower
tile逆时针直到到达upper tile间的所有tile，该图块也包含在集合中；
它环绕圆圈，如有必要会穿过\ :math:`\pm\infty` ！
这允许表示闭区间、开区间和半开区间，并且由于使用射影实数，连续区间在加法、减法、乘法和除法下\ **保持连续**\ 。
例如，上述环图的 {8,1} 环境中的半开区间 :math:`(-1/4,1/16]`
由一对tile表示

:math:`111000111 \to \color{red}-\color{orange}00\color{brown}1 \color{blue}1 \color{black}101 \color{magenta}1`\ ，表示tile
:math:`(-1/4, -7/23)`

:math:`001000000 \to \color{red}-\color{orange}00\color{brown}1 \color{blue}0 \color{black}000 \color{magenta}0`\ ，表示tile
:math:`1/16`

这是表示两点之间所有tile集合的紧凑方式：

.. math::


   (-1/4,-7/32), -7/32, (-7/32,-3/16),-3/16,\dots,3/64,(3/64,1/16),1/16

重申一下：posit算术是针对浮点数已经足够好的情况，并且算法已被证明足够可靠，能满足用户要求。
而valid算术适用于需要知道\ *答案上可证明的边界*\ 的情况。
或者当您仍在开发算法并调试其数值计算的行为时。
或者您想要描述实数集而不仅仅是点值。
valid数的算法通常与浮点数的算法有很大不同，反之亦然。
valid数可以表达对调试有用的丰富异常条件源，例如空集、整个实数集，或者在间隔太宽（根据用户设置）而无用时触发停止。
有关valid数使用的详细信息将在其他地方讨论，但现在感兴趣的读者可以参考《\ `错误的终结：Unum
计算方法 <https://jszheng.github.io/TheEndOfError/>`__\ 》一书中对“ubounds”的讨论。

可视化投影实数环上的regime位
----------------------------

现在我们已经展示了实数和整数如何在几何上映射到环，我们可以通过查看环的右半部分并显示useed的幂如何在环的顶部和底部聚集在一起，专门看看regime的分布：

.. figure:: assets/image-20230713225306034.png

   image-20230713225306034

这可能需要一些时间来理解，图中\ **regime-指数对**\ 描述了
2的幂的缩放因子，就像对 IEEE 标准浮点数指数（减去偏差）的描述一样。

如果 es 为 1 或更大，我们可以在 1
和used之间放置\ :math:`useed^{0.5}`\ ，在\ :math:`useed`\ 和\ :math:`useed^2`\ 之间放置\ :math:`useed^{1.5}`\ ，依此类推。
如果 es 为 2 或更大，我们会得到 1
和\ :math:`useed`\ 之间的等间距值\ :math:`useed^{0.25}`\ 、\ :math:`useed^{0.5}`\ 和\ :math:`useed^{0.75}`\ 。
换句话说，指数位是由regime位表示的useed的幂的小数部分。
